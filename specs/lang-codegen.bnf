keyword_lcurly : LCURLY
<<0
key = "sym#" + str(p.lexer.lineno) + "#" + str(p.lexer.lexpos)
symtab = SymbolTable(symTableDict[symTableSt[-1]], key)
symTableDict[key] = symtab
symTableSt += [key]
if (actRecordSt == []):
  pname = None
else:
  pname = actRecordSt[-1]
#actRecord = ActivationRecord(key)
#actRecordDict[key] = actRecord
#actRecordSt += [actRecord.getName()]
>>

keyword_rcurly : RCURLY
<<0
sym_table = symTableDict[symTableSt[-1]]
#act_record = actRecordDict[actRecordSt[-1]]
#act_record.setLocalVarsInputArgs(sym_table)
symTableSt = symTableSt[:-1]
#actRecordSt = actRecordSt[:-1]
>>

SourceFile  : PackageClause ImportDeclList TopLevelDeclList
<<0
for record_name in actRecordDict:
  if (record_name == "root"):
    continue
  actRecordDict[record_name].setGlobalVars(actRecordDict["root"].getGlobalVars())
  actRecordDict[record_name].setConstVars(actRecordDict["root"].getConstVars())
p[0]['dict_code'] = p[3]['dict_code']
print(symTableDict)
for key in symTableDict:
    symTableDict[key].prettyPrint()
print()
for key in actRecordDict:
    actRecordDict[key].prettyPrint()
print()
p[0]['activationRecords'] = actRecordDict
for key in p[0]['dict_code']:
  print(key + ":")
  for code, scope in zip(p[0]['dict_code'][key][0], p[0]['dict_code'][key][1]):
    print(code, "           | Scope:", scope)
  print()
>>

PackageClause  : PACKAGE IDENTIFIER

ImportDeclList : ImportDecl ImportDeclList
               | empty

ImportDecl    : IMPORT ImportSpecTopList

ImportSpecTopList : ImportSpec
                  | LPAREN ImportSpecList RPAREN

ImportSpecList : ImportSpec ImportSpecList
               | empty

ImportSpec       :  ImportSpecInit ImportPath

ImportSpecInit : DOT
               | IDENTIFIER
               | empty

ImportPath     : STRINGLIT
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
name = p[1].replace('"', '')
entry = ImportEntry(name)
if (symTable.put(entry) == False):
     print("Error:", name, "redeclared on line number", p.lexer.lineno)
     sys.exit(0)
>>

TopLevelDeclList : TopLevelDecl TopLevelDeclList
                 | empty
<<1
#p[0]['dict_code'].update(p[1]['dict_code'])
#p[0]['dict_code'].update(p[2]['dict_code'])
final_dict_code = {}
for key in p[1]['dict_code']:
  if key in p[2]['dict_code']:
    final_dict_code[key] = (p[1]['dict_code'][key][0] + p[2]['dict_code'][key][0], p[1]['dict_code'][key][1] + p[2]['dict_code'][key][1])
  else:
    final_dict_code[key] = (p[1]['dict_code'][key][0], p[1]['dict_code'][key][1])
for key in p[2]['dict_code']:
  if not key in p[1]['dict_code']:
    final_dict_code[key] = (p[2]['dict_code'][key][0], p[2]['dict_code'][key][1])
p[0]['dict_code'] = final_dict_code
>>
<<2
sym_table = symTableDict[symTableSt[-1]]
act_record = actRecordDict[actRecordSt[-1]]
act_record.setLocalVarsInputArgs(sym_table, symTableDict)
act_record.setGlobalVars(act_record.getLocalVars())
>>

TopLevelDecl  : Declaration
              | FunctionDecl
              | MethodDecl
              | InterfaceDecl
              | IFuncDef
              | StructDef
<<0
p[0]['dict_code'] = {}
>>
<<1
p[0]['dict_code']['global_decl'] = code_optimization(p[1]['global_decl'], p[1]['scope_global_decl'])
p[0]['dict_code']['const_decl'] = code_optimization(p[1]['const_decl'], p[1]['scope_const_decl'])
#print(p[0]['dict_code']['const_decl'])
>>
<<2
p[0]['dict_code'].update(p[1]['dict_code'])
>>
<<3
p[0]['dict_code'].update(p[1]['dict_code'])
>>

StructDef : TYPE IDENTIFIER STRUCT keyword_lcurly ParameterDeclList2 keyword_rcurly
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
struc = StructEntry(p[2])
struc.addFields(p[5]['fields'])
struc.setSize()
if (symTable.put(struc) == False):
     print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
     sys.exit(0)
>>

ParameterDeclList2  : ParameterDecl2 ParameterDeclList2
                    | empty
<<1
p[0]['fields'] = p[1]['fields']
p[0]['fields'].update(p[2]['fields'])
>>
<<2
p[0]['fields'] = {}
>>

ParameterDecl2  : IdentifierList1 Type
<<1
p[0]['fields'] = {}
for id in p[1]['idlist']:
  p[0]['fields'][id] = p[2]['type']
>>

InterfaceDecl : TYPE IDENTIFIER INTERFACE interfaceBlock
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
interfc = InterfaceEntry(p[2])
if (symTable.put(interfc) == False):
    print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
>>

interfaceBlock  : keyword_lcurly IFuncDecList keyword_rcurly

IFuncDecList   : IFuncDec IFuncDecList
               | empty

IFuncDec      : IDENTIFIER LPAREN RPAREN Type
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
if (symTable.put(fn) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
>>

IFuncDef      : FUNC LPAREN IDENTIFIER IDENTIFIER RPAREN IFuncDec Block

Block : keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['ret_typelist'] = p[2]['ret_typelist']
>>

StatementList : Statement StatementList
              | empty
<<0
p[0]['ret_typelist'] = []
>>
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['ret_typelist'] = [p[1]['typelist']] + p[2]['ret_typelist']
>>

Statement : Declaration
          | SimpleStmt
          | ReturnStmt
          | Block
          | IfStmt
          | SwitchStmt
          | ForStmt
          | FuncCallStmt
          | GoFunc
          | BreakStmt
          | ContinueStmt
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['typelist'] = []
>>
<<3
p[0]['typelist'] = p[1]['typelist']
>>
<<4
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<5
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<6
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<9
actRecordSt = actRecordSt[:-1]
>>

ContinueStmt : CONTINUE
             | CONTINUE IDENTIFIER
<<1
p[0]['code'] = ["goto beglabel"]
p[0]['scopelist'] =[actRecordSt[-1]]
>>
<<2
p[0]['code'] = ["goto " + p[2]]
p[0]['scopelist'] = [actRecordSt[-1]]
>>

BreakStmt : BREAK
<<0
p[0]['code'] = ["goto endlabel"]
p[0]['scopelist'] = [actRecordSt[-1]]
>>

GoFunc    : GO FUNC Parameters FunctionBody LPAREN ExpressionList RPAREN
          | GO IDENTIFIER LPAREN ExpressionListBot RPAREN
<<1
code = ["start_go_func:"] + p[6]['code']
scope = [actRecordSt[-1]] + p[6]['scopelist']
for id, value in zip(p[3]['idlist'], p[6]['namelist']):
    code += [id + " := " + value]
    scope += [actRecordSt[-1]]
code += p[4]['code']
p[0]['scopelist'] = scope + p[4]['scopelist']
p[0]['code'] = code + ["end_go_func"]
p[0]['scopelist'] += [actRecordSt[-1]]
>>
<<2
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[2])
if (symTable.put(fn) == False):
    print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
>>

FuncCallStmt : IDENTIFIER DOT FuncCallStmt
             | IDENTIFIER DOT IDENTIFIER LPAREN ExpressionListBot RPAREN
             | IDENTIFIER LPAREN ExpressionListBot RPAREN
<<0
p[0]['ret_types'] = []
p[0]['namelist'] = []
#actRecordSt += [actRecordSt[-1]]
#actRecordSt += ["root"]
#print(actRecordSt)
>>
<<1
actRecord = actRecordDict[p[1]]
actRecord.setParent(actRecordSt[-1])
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
  print("Function", p[1], "not defined on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['ret_types'] = p[3]['ret_types']
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
>>
<<2
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
  print("Function", p[1], "not defined on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['code'] = p[5]['code']
p[0]['scopelist'] = p[5]['scopelist']
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_alloc 4"] # 4 for now
  p[0]['scopelist'] += [actRecordSt[-1]]
for param in p[5]['namelist'][::-1]:
    p[0]['code'] += ["push_param " + param]
    p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += ["call " + p[1] + "." + p[3]]
p[0]['scopelist'] += [actRecordSt[-1]]
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_param " + name]
  p['scopelist'] += [actRecordSt[-1]]
>>
<<3
actRecord = actRecordDict[p[1]]
actRecord.setParent(actRecordSt[-1])
b = False
for scope in symTableSt:
  if p[1] in symTableDict[scope].symbols:
    b = True
    table = symTableDict[scope]
    break
if not b:
  print("Function", p[1], "not defined on line number", p.lexer.lineno)
  sys.exit(0)
entry = table.get(p[1])
p[0]['ret_types'] = entry.getReturnTypes()
#actRecordSt[-1] = entry.getName()
for typ in p[0]['ret_types']:
  p[0]['namelist'] += [newVar()]
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_alloc 4"] # 4 for now
  p[0]['scopelist'] += [actRecordSt[-1]]
for param in p[3]['namelist'][::-1]:
    p[0]['code'] += ["push_param " + param]
    p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += ["call " + p[1]]
p[0]['scopelist'] += [actRecordSt[-1]]
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_param " + name]
  p[0]['scopelist'] += [actRecordSt[-1]]
if entry.getInputArgs() != p[3]['typelist']:
   print("Function", p[1], "arguments mismatch at line num", p.lexer.lineno)
   sys.exit(0)
>>

ObjectMethod : IDENTIFIER DOT IDENTIFIER LPAREN ParameterDeclList2 RPAREN

Declaration : ConstDecl
            | TypeDecl
            | VarDecl
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['scope_global_decl'] = []
p[0]['scope_const_decl'] = []
p[0]['const_decl'] = []
p[0]['global_decl'] = []
>>
<<1
p[0]['const_decl'] = p[1]['code']
p[0]['scope_const_decl'] = p[1]['scopelist']
>>
<<3
p[0]['global_decl'] = p[1]['code']
p[0]['scope_global_decl'] = p[1]['scopelist']
>>

ConstDecl  : CONST ConstSpecTopList
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

ConstSpecTopList : ConstSpec
                 | LPAREN ConstSpecList RPAREN
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<2
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

ConstSpecList : ConstSpec ConstSpecList
              | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
>>

ConstSpec : IdentifierList1 ConstSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
actRecord = actRecordDict[actRecordSt[-1]]
if (len(p[1]['idlist']) != len(p[2]['namelist'])):
  print("Length mismatch on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
for i,j,k in zip(p[1]['idlist'], p[2]['namelist'], p[2]['typelist']):
    p[0]['code'] += [i + ' := ' + j]
    p[0]['scopelist'] += [actRecordSt[-1]]
    actRecord.putConstVar(i)
    lit = LitEntry(i, k)
    if (symTable.put(lit) == False):
      print("Error:", i, "redeclared on line number", p.lexer.lineno)
      sys.exit(0)
>>

ConstSpecTail : TypeTop EQ ExpressionList
              | empty
<<1
p[0]['namelist'] = p[3]['namelist']
p[0]['typelist'] = p[3]['typelist']
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
>>

TypeTop : Type
        | empty

IdentifierList1 : IDENTIFIER IdentifierBotList1
                | MULT IDENTIFIER IdentifierBotList1
<<1
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>
<<2
p[0]['idlist'] = [p[1]+p[2]] + p[3]['idlist']
>>

IdentifierBotList1 :  IdentifierBotList1 COMMA IDENTIFIER
                  |  IdentifierBotList1 COMMA MULT IDENTIFIER
                  | empty
<<1
p[0]['idlist'] = p[1]['idlist'] + [p[3]]
>>
<<2
p[0]['idlist'] = p[1]['idlist'] + [p[3]+p[4]]
>>
<<3
p[0]['idlist'] = []
>>

IdentifierList3 : IDENTIFIER IdentifierBotList3
                | MULT IDENTIFIER IdentifierBotList3
                | IDENTIFIER DOT IDENTIFIER IdentifierBotList3
<<1
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>
<<2
p[0]['idlist'] = [p[1] + p[2]] + p[3]['idlist']
>>
<<3
p[0]['idlist'] = [p[1] + p[2] + p[3]] + p[4]['idlist']
>>

IdentifierBotList3 : IdentifierBotList3 COMMA IDENTIFIER
                   | IdentifierBotList3 COMMA MULT IDENTIFIER
                   | IdentifierBotList3 COMMA IDENTIFIER DOT IDENTIFIER 
                   | empty
<<1
p[0]['idlist'] = p[1]['idlist'] + [p[3]]
>>
<<2
p[0]['idlist'] = p[1]['idlist'] + [p[3] + p[4]]
>>
<<3
p[0]['idlist'] = p[1]['idlist'] + [p[3] + p[4] + p[5]]
>>
<<4
p[0]['idlist'] = []
>>

IdOrArrayElemList : IdOrArrayElem IdOrArrayElemBotList
<<0
p[0]['idlist'] = [p[1]['id']] + p[2]['idlist']
p[0]['idxlists'] = [p[1]['idxlist']] + p[2]['idxlists']
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
>>

IdOrArrayElemBotList : IdOrArrayElemBotList COMMA IdOrArrayElem
                      | empty
<<1
p[0]['idlist'] = p[1]['idlist'] + [p[3]['id']]
p[0]['idxlists'] = p[1]['idxlists'] + [p[3]['idxlist']]
p[0]['code'] = p[1]['code'] + p[3]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist']
>>
<<2
p[0]['idlist'] = []
p[0]['idxlists'] = []
>>

IdOrArrayElem : IDENTIFIER MoreDims
<<0
p[0]['id'] = p[1]
p[0]['idxlist'] = p[2]['idxlist']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

MoreDims : LSQUARE Expression RSQUARE MoreDims
           | empty
<<1
p[0]['idxlist'] = [p[2]['place']] + p[4]['idxlist']
p[0]['code'] = p[2]['code'] + p[4]['code']
p[0]['scopelist'] = p[2]['scopelist'] + p[4]['scopelist']
>>
<<2
p[0]['idxlist']  = []
>>

ExpressionList :  Expression ExpressionBotList
               |  FuncCallStmt ExpressionBotList
<<0
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
>>
<<1
p[0]['namelist'] = [p[1]['place']] + p[2]['namelist']
p[0]['typelist'] = [p[1]['type']] + p[2]['typelist']
>>
<<2
p[0]['namelist'] = p[1]['namelist'] + p[2]['namelist']
p[0]['typelist'] = p[1]['ret_types'] + p[2]['typelist']
#actRecordSt = actRecordSt[:-1]
>>

ExpressionBotList : ExpressionBotList COMMA Expression
                  | empty
<<1
p[0]['namelist'] = p[1]['namelist'] + [p[3]['place']]
p[0]['typelist'] = p[1]['typelist'] + [p[3]['type']]
p[0]['code'] = p[1]['code'] + p[3]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

TypeDecl : TYPE TypeSpecTopList

TypeSpecTopList : TypeSpec
                | LPAREN TypeSpecList  RPAREN

TypeSpecList : TypeSpec TypeSpecList SEMICOLON
             | empty

TypeSpec : AliasDecl
         | TypeDef

AliasDecl : IDENTIFIER EQ Type

TypeDef : IDENTIFIER Type
<<0
print(p[2])
scope = symTableSt[-1]
symTable = symTableDict[scope]
var = VarEntry(p[1])
var.setDim(p[2]['dim'])
var.setDimRanges(p[2]['dimrange'])
if (symTable.put(var) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
>>

Type : TypeName
     | TypeLit
     | LPAREN Type RPAREN
<<0
p[0]['dim'] = 0
p[0]['dimrange'] = []
>>
<<1
p[0]['type'] = p[1]['type']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<2
p[0]['type'] = p[1]['type']
p[0]['dim'] = p[1]['dims']
p[0]['dimrange'] = p[1]['dimrange']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<3
p[0]['type'] = p[2]['type']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist'] 
>>

TypeName  : IDENTIFIER
          | MULT IDENTIFIER
          | QualifiedIdent
<<1
p[0]['type'] = p[1]
>>
<<2
p[0]['type'] = "*" + p[2]
>>
<<3
p[0]['type'] = p[1]['type']
>>

QualifiedIdent : IDENTIFIER DOT IDENTIFIER
<<0
p[0]['type'] = verifyCalType(p[3], p.lexer.lineno)
>>

TypeLit  : ArrayType
         | StructType
         | FunctionType
<<0
p[0]['type'] = p[1]['type']
p[0]['dimrange'] = []
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<1
p[0]['dims'] = p[1]['dims']
p[0]['dimrange'] = p[1]['dimrange']
>>

ArrayType  : LSQUARE ArrayLength RSQUARE ElementType
<<0
if p[2]['type'] != "int" and p[2]['type'] != '':
  print("Array index error on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['type'] = p[4]['type']
p[0]['dims'] = 1 + p[4]['dims']
p[0]['dimrange'] = [p[2]['place']] + p[4]['dimrange']
p[0]['code'] = p[2]['code'] + p[4]['code']
p[0]['scopelist'] = p[2]['scopelist'] + p[4]['scopelist']
>>

ArrayLength : Expression
            | empty
<<1
p[0]['type'] = p[1]['type']
p[0]['place'] = p[1]['place']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<2
p[0]['type'] = ''
p[0]['place'] = ''
>>

ElementType : Type
<<0
p[0]['type'] = p[1]['type']
p[0]['dims'] = p[1]['dim']
p[0]['dimrange'] = p[1]['dimrange']
>>

StructType    : STRUCT keyword_lcurly FieldDeclList keyword_rcurly

FieldDeclList : FieldDecl FieldDeclList SEMICOLON
              | empty

FieldDecl  : FieldDeclHead TagTop

TagTop : Tag
       | empty

FieldDeclHead : IdentifierList1 Type
              | EmbeddedField

EmbeddedField : starTop TypeName

starTop : MULT
        | empty

Tag : STRINGLIT

FunctionType  : FUNC Signature

ResultTop : Result
          | empty
<<1
p[0]['ret_types'] = p[1]['ret_types']
>>
<<2
p[0]['ret_types'] = []
>>

Result   : Ret_Types
         | Type
<<1
p[0]['ret_types'] = p[1]['ret_types']
>>
<<2
p[0]['ret_types'] = [p[1]['type']]
>>

Ret_Types  : LPAREN TypeList RPAREN
<<0
p[0]['ret_types'] = p[2]['types']
>>

TypeList : Type TypeListBot
         | empty
<<1
p[0]['types'] = [p[1]['type']] + p[2]['types']
>>
<<2
p[0]['types'] = []
>>

TypeListBot : COMMA Type TypeListBot
          | empty
<<1
p[0]['types'] = [p[2]['type']] + p[3]['types']
>>
<<2
p[0]['types'] = []
>>

Parameters  : LPAREN ParameterListTop RPAREN
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['args_types'] = p[2]['args_types']
p[0]['idlist'] = p[2]['idlist']
params = p[2]['idlist']
scope = symTableSt[-1]
for param,t,dim,dimrange in zip(params, p[0]['args_types'],p[2]['dims'], p[2]['dimranges']):
    table = symTableDict[scope]
    entry = VarEntry(param)
    entry.setType(t, table)
    entry.setDim(dim)
    entry.setDimRanges(dimrange)
    entry.isNotLocal()
    decl  = "_decl array " + t + " " + param
    decl_tail = ""
    for dr in dimrange:
        decl_tail += " " + dr
    decl += decl_tail
    toks = decl.split()
    if len(toks) > 4:
      p[0]['code'] += [decl]
      p[0]['scopelist'] += [actRecordSt[-1]]
    if (table.put(entry) == False):
        print("Error:", param, "redeclared on line number", p.lexer.lineno)
        sys.exit(0)
>>

ParameterListTop : ParameterList commaTop
                 | empty
<<1
p[0]['args_types'] = p[1]['args_types']
p[0]['idlist'] = p[1]['idlist']
p[0]['dims'] = p[1]['dims']
p[0]['dimranges'] = p[1]['dimranges']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<2
p[0]['args_types'] = []
p[0]['idlist'] = []
p[0]['dims'] = []
p[0]['dimranges'] = []
>>

commaTop : COMMA
         | empty

ParameterList  : ParameterDecl ParameterDeclList
<<0
p[0]['args_types'] = [p[1]['type']] + p[2]['args_types']
p[0]['idlist'] = p[1]['idlist'] + p[2]['idlist']
p[0]['dims'] = [p[1]['dim']] + p[2]['dims']
p[0]['dimranges'] = [p[1]['dimrange']] + p[2]['dimranges']
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
>>

ParameterDeclList : COMMA ParameterDecl ParameterDeclList
                  | empty
<<1
p[0]['args_types'] = [p[2]['type']] + p[3]['args_types']
p[0]['idlist'] = p[2]['idlist'] + p[3]['idlist']
p[0]['dims'] = [p[2]['dim']] + p[3]['dims']
p[0]['dimranges'] = [p[2]['dimrange']] + p[3]['dimranges']
p[0]['code'] = p[2]['code'] + p[3]['code']
p[0]['scopelist'] = p[2]['scopelist'] + p[3]['scopelist']
>>
<<2
p[0]['args_types'] = []
p[0]['idlist'] = []
p[0]['dims'] = []
p[0]['dimranges'] = []
>>

ParameterDecl  : ParameterDeclHead tripledotTop Type
<<0
p[0]['type'] = p[3]['type']
p[0]['idlist'] = p[1]['idlist']
p[0]['dim'] = p[3]['dim']
p[0]['dimrange'] = p[3]['dimrange']
p[0]['code'] = p[1]['code'] + p[3]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist']
>>

tripledotTop : DOT_DOT_DOT
             | empty
<<1
p[0]['symbol'] = '...'
>>
<<2
p[0]['symbol'] = ''
>>

ParameterDeclHead : IdentifierList1
                  | empty
<<1
p[0]['idlist'] = p[1]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

VarDecl : VAR VarSpecTopList
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
sym_table = symTableDict[symTableSt[-1]]
var_symbols = sym_table.getVarSymbols()
var_names = p[2]['idlist']
for var_name in var_names:
  if var_name not in var_symbols:
     print("Error:", var_name, "not found on symbol table at linenum", p.lexer.lineno)
     sys.exit(0)
  var_entry = var_symbols[var_name]
  type = var_entry.getType()
  if (var_entry.getDim() <= 0):
    continue
  dim_ranges = var_entry.getDimRanges()
  decl_tail = " "
  for d in range(var_entry.getDim()):
    decl_tail += " " + dim_ranges[d]
  decl = "_decl array " + type + " " + var_entry.getName() + decl_tail
  var_entry.setType(type, sym_table)
  p[0]['code'] += [decl]
  p[0]['scopelist'] += [actRecordSt[-1]]
>>

VarSpecTopList : VarSpec
               | LPAREN VarSpecList RPAREN
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['idlist'] = p[1]['idlist']
>>
<<2
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['idlist'] = p[2]['idlist']
>>

VarSpecList : VarSpec VarSpecList SEMICOLON
            | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['idlist'] = p[1]['idlist'] + p[2]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

VarSpec  : IdOrArrayElemList VarSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
if ((p[2]['type_used'] == False) and  len(p[1]['idlist']) != len(p[2]['namelist'])):
  print("Length mismatch on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['idlist'] = p[1]['idlist']
mylist = p[1]['idlist']
mytypelist = p[2]['typelist']
myidxlists = p[1]['idxlists']
mynamelist = p[2]['namelist']
#for name, typ in zip(p[1]['idlist'], p[2]['typelist']):
#    p[0]['code'] += ["_decl " + typ + " " + name]
for index in range(len(mylist)):
    i = mylist[index]
    var = VarEntry(i)
    var.setDim(len(myidxlists[index]))
    var.setDimRanges(myidxlists[index])
    if (index < len(mynamelist)):
      p[0]['code'] += [i + " := " + mynamelist[index]]
      p[0]['scopelist'] += [actRecordSt[-1]]
    if (p[2]['type_used'] == False):
      var.setType(mytypelist[index], symTable)
    else:
      var.setType(p[2]['typelist'][0], symTable)
    if (symTable.put(var) == False):
        print("Error:", i, "redeclared on line number", p.lexer.lineno)
        sys.exit(0)
>>

VarSpecTail : Type VarSpecMid
            | EQ ExpressionList
<<0
p[0]['namelist'] = p[2]['namelist']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>
<<1
p[0]['typelist'] = [p[1]['type']]
p[0]['type_used'] = True
>>
<<2
p[0]['typelist'] = p[2]['typelist']
p[0]['type_used'] = False
>>

VarSpecMid : EQ ExpressionList
           | empty
<<1
p[0]['namelist'] = p[2]['namelist']
p[0]['typelist'] = p[2]['typelist']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

FunctionDecl : FUNC Signature FunctionBodyTop
<<0
p[0]['scopelist'] = p[2]['scopelist'] + p[3]['scopelist']
this_func_sym_table = symTableDict[symTableSt[-1]]
act_record = actRecordDict[actRecordSt[-1]]
actRecordSt = actRecordSt[:-1]
symTableSt = symTableSt[:-1]
input_args = p[2]['input_args']
ret_types = p[2]['ret_types']
func_name = p[2]['func_name']
scope = symTableSt[-1]
table = symTableDict[scope]
entry = symTableDict[symTableSt[-1]].get(func_name)
act_record.setLocalVarsInputArgs(this_func_sym_table, symTableDict)
#act_record.storeOldStPtr("%rbp")
act_record.setRetValues(entry)
p[0]['code'] = p[2]['code'] + p[3]['code']
p[0]['dict_code'] = { func_name: code_optimization(p[0]['code'], p[0]['scopelist']) }
p[3]['ret_actual_types'] = flatten_list(p[3]['ret_actual_types'])
for ret_actual in p[3]['ret_actual_types']:
      if (len(ret_actual) > 0 and p[2]['ret_types'] != ret_actual):
           print("Error:", func_name, "return types mismatch on line number", p.lexer.lineno)
           sys.exit(0)
>>

Signature  : FunctionName Parameters ResultTop
<<0
func_name = p[1]['func_name']
p[0]['input_args'] = p[2]['args_types']
p[0]['ret_types'] = p[3]['ret_types']
p[0]['func_name'] = func_name
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
entry = symTableDict[symTableSt[-2]].get(func_name)
entry.setInputArgs(p[0]['input_args'])
entry.setReturnTypes(p[0]['ret_types'])
>>

FunctionBodyTop : FunctionBody
                | empty
<<0
p[0]['ret_actual_types'] = []
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['ret_actual_types'] = p[1]['ret_typelist']
>>

FunctionDeclTail : Function
                 | Signature
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['input_args'] = p[1]['input_args']
p[0]['ret_types'] = p[1]['ret_types']
p[0]['ret_actual_types'] = []
>>
<<1
p[0]['ret_actual_types'] = p[1]['ret_actual_types']
>>

FunctionName : IDENTIFIER
<<0
table = symTableDict[symTableSt[-1]]
entry = FuncEntry(p[1])
if (table.put(entry) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
p[0]['func_name'] = p[1]
key = "sym#" + str(p.lexer.lineno) + "#" + str(p.lexer.lexpos)
symtab = SymbolTable(symTableDict[symTableSt[-1]], key)
symTableDict[key] = symtab
symTableSt += [key]
if (actRecordSt == []):
  pname = None
else:
  pname = actRecordSt[-1]
actRecord = ActivationRecord(p[1])
if (p[1] == "main"):
   actRecord.setParent("root")
symtab.removeMe(symtab.getName(), symTableDict)
actRecordDict[p[1]] = actRecord
actRecordSt += [actRecord.getName()]
>>

Function  : Signature FunctionBody
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['input_args'] = p[1]['input_args']
p[0]['ret_types'] = p[1]['ret_types']
p[0]['ret_actual_types'] = p[2]['ret_typelist']
>>

FunctionBody : LCURLY StatementList RCURLY
<<0
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['ret_typelist'] = p[2]['ret_typelist']
>>

MethodDecl : FUNC Receiver MethodName FunctionDeclTail
<<0
p[0]['code'] = p[2]['code'] + p[3]['code'] + p[4]['code']
p[0]['scopelist'] = p[2]['scopelist'] + p[3]['scopelist'] + p[4]['scopelist']
p[0]['dict_code'] = { p[3]: code_optimization(p[0]['code'], p[0]['scopelist']) }
>>

MethodName : IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
if (symTable.put(fn) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
    sys.exit(0)
>>

Receiver  : Parameters

SimpleStmt : ExpressionStmt
           | Assignment
           | AssignmentGen
           | ShortVarDecl
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['place'] = ''
>>
<<1
p[0]['place'] = p[1]['place']
>>

SimpleStmtBot : SimpleStmt
           | empty
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['place'] = p[1]['place']
>>
<<2
p[0]['place'] = ""
>>

ExpressionStmt : Expression
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['place'] = p[1]['place']
>>

ShortVarDecl : IdentifierList3 SHORT_ASSIGN ExpressionList
<<0
for name, typ in zip(p[1]['idlist'], p[3]['typelist']):
    p[0]['code'] += ["_decl " + typ + " " + name]
    p[0]['scopelist'] += [actRecordSt[-1]]
scope = symTableSt[-1]
table = symTableDict[scope]
p[0]['code'] += p[3]['code']
p[0]['scopelist'] += p[3]['scopelist']
if (len(p[1]['idlist']) != len(p[3]['namelist'])):
   print("Left and right side not equal on line number", p.lexer.lineno)
   sys.exit(0)
for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
  p[0]['code'] += [i + ' := ' + j]
  p[0]['scopelist'] += [actRecordSt[-1]]
  entry = VarEntry(i)
  entry.setType(k, table)
  if (table.put(entry) == False):
     print("Error:", i, "redeclared on line number", p.lexer.lineno)
     sys.exit(0)
>>

Assignment : IdentifierList3 assign_op ExpressionList
<<0
for id in p[1]['idlist']:
  id = id.split(".")[0]
  b = False
  if id[0] in ['*']:
     id = id[1:]
  for scope in symTableSt:
    if id in symTableDict[scope].symbols:
      b = True
      break
  if not b:
    print("Error:", id, "not defined on line number", p.lexer.lineno)
    sys.exit(0)
p[0]['code'] = p[1]['code'] + p[3]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist']
if (p[2]['len'] == 1):
  for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
    q = i
    if q[0] in ['*']:
       q = q[1:]
    left_elem_type = verifyCalType(q, p.lexer.lineno)
    if i[0] in ['*']:
       left_elem_type = left_elem_type[1:]
    if left_elem_type != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +left_elem_type+", got type "+ k)
      sys.exit(0)
    p[0]['code'] += [i + ' := ' + j] 
    p[0]['scopelist'] += [actRecordSt[-1]]
else:
  for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
    q = i
    if q[0] in ['*']:
       q = q[1:]
    left_elem_type = verifyCalType(q, p.lexer.lineno)
    if i[0] in ['*']:
      left_elem_type = left_elem_type[1:]
    if left_elem_type != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +left_elem_type+", got type "+ k)
      sys.exit(0)
    var = newVar()
    var_dest = newVar()
    p[0]['code'] += [var + " := " + i]
    p[0]['code'] += [var_dest + ' :=  '+ var + " " + p[2]['symbol'] + k + " " + j]
    p[0]['code'] += [i + " := " + var_dest]
    p[0]['scopelist'] += [actRecordSt[-1], actRecordSt[-1], actRecordSt[-1]]
>>

AssignmentGen : IdOrArrayElemList assign_op ExpressionList
<<0
p[0]['code'] = p[1]['code'] + p[3]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist']
for i, idx,  j, k in zip(p[1]['idlist'], p[1]['idxlists'],  p[3]['namelist'], p[3]['typelist']):
  q = i
  if q[0] in ['*']:
    q = q[1:]
  left_elem_type = verifyCalType(q, p.lexer.lineno)
  if i[0] in ['*']:
    left_elem_type = left_elem_type[1:]
  if left_elem_type != k:
    print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +left_elem_type+", got type "+ k)
    sys.exit(0)
  for n in symTableSt[::-1]:
    if i in symTableDict[n].symbols:
      table = symTableDict[n]
  entry = table.get(i)
  if (entry.getDim() != len(idx)):
    print("Error: dimention mismatch at line number", p.lexer.lineno)
    sys.exit(0)
if (p[2]['len'] == 1):
    loc = ""
    for l in idx:
      loc += "[" + l + "]"
    p[0]['code'] += [i + loc + ' := ' + j]
    p[0]['scopelist'] += [actRecordSt[-1]]
else:
    p[0]['code'] += [i + ' := ' + i + str(idx) + p2['symbol'] + j]
    p[0]['scopelist'] += [actRecordSt[-1]]
>>

assign_op : addmul_op EQ
<<0
p[0]['len'] = 1 + p[1]['len']
p[0]['symbol'] = p[1]['symbol']
>>

addmul_op : add_op
          | mul_op
          | empty
<<1
p[0]['len'] = 1
p[0]['symbol'] = p[1]['symbol']
>>
<<2
p[0]['len'] = 1
p[0]['symbol'] = p[1]['symbol']
>>
<<3
p[0]['len'] = 0
p[0]['symbol'] = ''
>>

IfStmt : IF SimpleStmtBot ExpressionBot Block elseBot
<<0
p[0]['lastlabel'] = p[5]['lastlabel']
p[4]['label'] = newLabel()
if (p[2]['place'] == ''):
   print("Inadequate condition at line num", p.lexer.lineno)
   sys.exit(0)
if (p[5]['symbol'] != ""):
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " " +p[5]['symbol']]
   p[0]['scopelist'] = p[2]['scopelist'] + [actRecordSt[-1]]
else:
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " else goto " +p[0]['lastlabel']]
   p[0]['scopelist'] = p[2]['scopelist'] + [actRecordSt[-1]]
   
p[0]['code'] += [p[4]['label'] + ':'] + p[4]['code'] + ["goto " + p[0]['lastlabel']]
p[0]['scopelist'] += [actRecordSt[-1]] + p[4]['scopelist'] + [actRecordSt[-1]]
p[0]['code'] += p[5]['code'] + [p[0]['lastlabel'] +": "]
p[0]['scopelist'] += p[5]['scopelist'] + [actRecordSt[-1]]
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

IfStmt2 : IF SimpleStmtBot ExpressionBot Block elseBot
<<0
p[0]['lastlabel'] = p[5]['lastlabel']
p[4]['label'] = newLabel()
if (p[2]['place'] == ''):
   print("Inadequate condition at line num", p.lexer.lineno)
   sys.exit(0)
if (p[5]['symbol'] != ""):
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " " +p[5]['symbol']]
   p[0]['scopelist'] = p[2]['scopelist'] + [actRecordSt[-1]]
else:
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " else goto " +p[0]['lastlabel']]
   p[0]['scopelist'] = p[2]['scopelist'] + [actRecordSt[-1]]
   
p[0]['code'] += [p[4]['label'] + ':'] + p[4]['code'] + ["goto " + p[0]['lastlabel']]
p[0]['scopelist'] += [actRecordSt[-1]] + p[4]['scopelist'] + [actRecordSt[-1]]
p[0]['code'] += p[5]['code']
p[0]['scopelist'] += p[5]['scopelist']
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

SimpleStmtBot : SimpleStmt
              | TRUE
              | FALSE
              | empty
<<0
p[0]['code'] = []
p[0]['scopelist'] = []
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['place'] = p[1]['place']
>>
<<2
p[1]['place'] = 'true'
>>
<<3
p[0]['place'] = 'false'
>>
<<4
p[0]['place'] = ''
>>

elseBot : ELSE elseTail
        | empty
<<1
p[2]['label'] = newLabel()
p[0]['symbol'] = 'else goto ' + p[2]['label']
p[0]['code'] = [p[2]['label'] + ' : '] + p[2]['code']
p[0]['scopelist'] = [actRecordSt[-1]] + p[2]['scopelist']
p[0]['lastlabel'] = p[2]['lastlabel']
>>
<<2
p[0]['symbol'] = ''
p[0]['code'] = []
p[0]['scopelist'] = []
p[0]['lastlabel'] = newLabel()
>>

elseTail : IfStmt2
         | Block
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<1
p[0]['lastlabel'] = p[1]['lastlabel']
>>
<<2
p[0]['lastlabel'] = newLabel()
>>

SwitchStmt : ExprSwitchStmt
<<0
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['ret_typelist'] = p[1]['ret_typelist']
>>

ExprSwitchStmt : SWITCH IDENTIFIER keyword_lcurly ExprCaseClauseList keyword_rcurly
<<0
b = False
for scope in symTableSt:
	if p[2] in symTableDict[scope].symbols:
		b = True
		break
if not b:
  print("Switch variable", p[2], "not declared on line number", p.lexer.lineno)
  sys.exit(0)
p[0]['code'] = p[4]['expcodelist']
p[0]['scopelist'] = p[4]['expscopelist']
for exp, label in zip(p[4]['explist'], p[4]['labellist'][:-1]):
  exp_var = newVar()
  var = newVar()
  var2 = newVar()
  p[0]['code'] += [exp_var + " := " + exp]
  p[0]['scopelist'] += [actRecordSt[-1]]
  p[0]['code'] += [var2 + " := " + p[2]]
  p[0]['scopelist'] += [actRecordSt[-1]]
  p[0]['code'] += [var + " := " + var2 + ' == ' + exp_var]
  p[0]['scopelist'] += [actRecordSt[-1]]
  p[0]['code'] += ['if ' + var + ' goto ' + label]
  p[0]['scopelist'] += [actRecordSt[-1]]
for label, codeblock in zip(p[4]['labellist'][:-1], p[4]['code']):
  p[0]['code'] += codeblock
  p[0]['scopelist'] += [actRecordSt[-1]]*len(codeblock)
  p[0]['code'] += ['goto ' + p[4]['labellist'][-1]]
  p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += [p[4]['labellist'][-1] + ':']
p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

ExprCaseClauseList : ExprCaseClause ExprCaseClauseList
                   | empty
<<1
p[0]['explist'] = [p[1]['exp']] + p[2]['explist']
p[0]['expcodelist'] = p[1]['expcode'] + p[2]['expcodelist']
p[0]['expscopelist'] = p[1]['expscope'] + p[2]['expscopelist']
p[0]['labellist'] = [p[1]['label']] + p[2]['labellist']
p[0]['code'] = [p[1]['code']] + p[2]['code']
p[0]['scopelist'] = [actRecordSt[-1]] + p[2]['scopelist']
p[0]['ret_typelist'] = [p[1]['ret_typelist']] + p[2]['ret_typelist']
>>
<<2
p[0]['explist'] = []
p[0]['expcodelist'] = []
p[0]['expscopelist'] = []
p[0]['labellist'] = [newLabel()]
p[0]['code'] = []
p[0]['scopelist'] = []
p[0]['ret_typelist'] = []
>>

ExprCaseClause : ExprSwitchCase COLON keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['exp'] = p[1]['exp']
p[0]['expcode'] = p[1]['code']
p[0]['expscope'] = p[1]['scopelist']
p[0]['label'] = newLabel()
p[0]['code'] = [p[0]['label'] + ' : '] + p[4]['code']
p[0]['scopelist'] = [actRecordSt[-1]] + p[4]['scopelist']
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

ExprSwitchCase : CASE Expression
               | DEFAULT
<<1
p[0]['exp'] = p[2]['place']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

ForStmt : FOR SimpleStmtBot SEMICOLON SimpleStmtBot SEMICOLON SimpleStmtBot Block
<<1
p[0]['code'] = p[2]['code'] + p[4]['code']
p[0]['scopelist'] = p[2]['scopelist'] + p[4]['scopelist']
beglabel = newLabel()
endlabel = newLabel()
if (p[4]['place'] != ""):
  p[0]['code'] += ["if " + p[4]['place'] + " goto " + beglabel + " else goto " + endlabel]
  p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += [beglabel + ":"]
p[0]['scopelist'] += [actRecordSt[-1]]
for line in p[7]['code']:
  if (line == "goto endlabel"):
    p[0]['code'] += ["goto " + endlabel]
    p[0]['scopelist'] += [actRecordSt[-1]]
  elif (line == "goto beglabel"):
    p[0]['code'] += p[6]['code']
    p[0]['scopelist'] += p[6]['scopelist']
    p[0]['code'] += ["goto " + beglabel]
    p[0]['scopelist'] += [actRecordSt[-1]]
  else:
    p[0]['code'] += [line]
    p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += p[6]['code']
p[0]['scopelist'] += p[6]['scopelist']
p[0]['code'] += p[4]['code']
p[0]['scopelist'] += p[4]['scopelist']
if (p[4]['place'] != ""):
  p[0]['code'] += ["if " + p[4]['place'] + " goto " + beglabel + " else goto " + endlabel]
  p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += [endlabel + ":"]
p[0]['scopelist'] += [actRecordSt[-1]]
>>

ExpressionBot : Expression
              | empty
<<1
p[0]['symbol'] = p[1]['code'][-1] 
>>
<<2
p[0]['symbol'] = ''
>>

ReturnStmt : RETURN ExpressionListBot
<<0
p[0]['typelist'] = p[2]['typelist']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
for name in p[2]['namelist']:
      p[0]['code'] += ["ret " + name]
      p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['code'] += ['func_end']
p[0]['scopelist'] += [actRecordSt[-1]]
>>

ExpressionListBot : ExpressionList
                  | empty
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['typelist'] = p[1]['typelist']
p[0]['namelist'] = p[1]['namelist']
>>
<<2
p[0]['typelist'] = []
p[0]['namelist'] = []
>>

Expression : UnaryExpr
           | Expression binary_op Expression
           | IDENTIFIER DOT IDENTIFIER
           | IDENTIFIER keyword_lcurly ObjectParamList keyword_rcurly
<<0
p[0]['type'] = ''
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['type'] = p[1]['type']
p[0]['place'] = p[1]['place']
>>
<<2
p[0]['place'] = newVar()
if p[1]['type'] == p[3]['type']:
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := ' + p[1]['place'] +" "+ p[2]['symbol'] + p[1]['type']+" " + p[3]['place']]
  p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist'] + [actRecordSt[-1]]
  p[0]['type'] = p[1]['type']
elif (p[1]['type']=='float' and p[3]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-float ' + p[1]['place']+" " + p[2]['symbol'] + 'float ' + p[3]['place']]
  p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist'] + [actRecordSt[-1]]
  p[0]['type'] ='float'
elif (p[3]['type']=='float' and p[1]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-float ' + p[3]['place'] +" "+ p[2]['symbol'] + 'float ' + p[1]['place']]
  p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist'] + [actRecordSt[-1]]
  p[0]['type'] ='float'
elif (p[1]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-string ' + p[3]['place'] +" "+ p[2]['symbol'] + 'string ' + p[1]['place']]
  p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist'] + [actRecordSt[-1]]
  p[0]['type'] ='string'
elif (p[3]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-string ' + p[1]['place'] +" "+ p[2]['symbol'] + 'string ' + p[3]['place']]
  p[0]['scopelist'] = p[1]['scopelist'] + p[3]['scopelist'] + [actRecordSt[-1]]
  p[0]['type'] ='string'
>>
<<3
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ' := ' + p[1] + '.' + p[3]]
p[0]['scopelist'] = [actRecordSt[-1]]
sym_table = symTableDict[symTableSt[-1]]
symbols = sym_table.getSymbols()
if p[1] not in symbols:
   print("Error: type of", p[1], "could not be found on line number", p.lexer.lineno)
   sys.exit(0)
var_entry = symbols[p[1]]
sign = var_entry.getSign()
typ = sign[p[3]][2]
p[0]['type'] = typ
>>
<<4
p[0]['place'] = newVar()
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
p[0]['type'] = p[1]
p[0]['field_ass'] = p[3]['field_ass']
code_so_far = p[0]['code'] # Following code is little optimization for saving registers
i = 0
j = 0
res = []
resscope = []
for asgn in p[3]['field_ass']:
  tmp_name = asgn[1]
  this_code = p[0]['place'] + "." + asgn[0] + " := " + asgn[1]
  for j in range(i, len(code_so_far)):
    if tmp_name in code_so_far[j]:
      res += [code_so_far[j], this_code]
      resscope += [actRecordSt[-1], actRecordSt[-1]]
      i = j + 1
      break
    else:
      res += [code_so_far[j]]
      resscope += [actRecordSt[-1], actRecordSt[-1]]
  if (j == len(code_so_far)):
    res += [this_code]
    resscope += [actRecordSt[-1]]
p[0]['code'] = res
p[0]['scopelist'] = resscope 
>>

ObjectParamList : ObjectParam ObjectParamTop
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['field_ass'] = p[1]['field_ass'] + p[2]['field_ass']
>>

ObjectParamTop : COMMA ObjectParamTop
               | COMMA ObjectParam
               | empty
<<1
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['field_ass'] = p[2]['field_ass']
>>
<<2
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['field_ass'] = p[2]['field_ass']
>>
<<3
p[0]['code'] = []
p[0]['scopelist'] = []
p[0]['field_ass'] = []
>>

ObjectParam   : IDENTIFIER COLON Expression
<<1
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
p[0]['field_ass'] = [(p[1], p[3]['place'])]
>>

UnaryExpr  : unary_op UnaryExpr
           | PrimaryExpr
           | MULT IDENTIFIER
<<1
p[0]['place'] = newVar()
p[0]['type'] = p[2]['type']
if (p[1]['symbol'] == "&"):
  p[0]['type'] = "*" + p[0]['type']
p[0]['code'] = p[2]['code'] + [p[0]['place'] + ' := ' + p[1]['symbol'] + p[2]['place']]
p[0]['scopelist'] = p[2]['scopelist'] + [actRecordSt[-1]]
>>
<<2
p[0]['place'] = p[1]['place']
p[0]['type'] = p[1]['type']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<3
p[0]['place'] = newVar()
p[0]['type'] = verifyCalType(p[2], p.lexer.lineno)[1:]
p[0]['code'] = [p[0]['place'] + " := " + "*" + p[2]]
p[0]['scopelist'] = [actRecordSt[-1]]
>>

binary_op  : OR_OR
           | AND_AND
           | rel_op
           | add_op
           | mul_op
           | MOD
<<1
p[0]['symbol'] = p[1]
>>
<<2
p[0]['symbol'] = p[1]
>>
<<3
p[0]['symbol'] = p[1]['symbol']
>>
<<4
p[0]['symbol'] = p[1]['symbol']
>>
<<5
p[0]['symbol'] = p[1]['symbol']
>>
<<6
p[0]['symbol'] = p[1]
>>

rel_op  : EQ_EQ
        | NOT_EQ
        | LESS
        | LESS_EQ
        | GREATER
        | GREATER_EQ
<<0
p[0]['symbol'] = p[1]
>>

add_op  : ADD
        | MINUS
        | OR
        | POW
<<0
p[0]['symbol'] = p[1]
>>

mul_op  : MULT
        | DIV
        | LSHIFT
        | RSHIFT
        | AND
        | AND_POW
<<0
p[0]['symbol'] = p[1]
>>

unary_op  : ADD
          | MINUS
          | NOT
          | POW
          | MULT
          | AND
          | RECEIVE
<<0
p[0]['symbol'] = p[1]
>>

PrimaryExpr : Operand
            | PrimaryExpr Selector
            | PrimaryExpr Index
            | PrimaryExpr Arguments
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place']]
p[0]['scopelist'] += [actRecordSt[-1]]
>>
<<2
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
p[0]['scopelist'] += [actRecordSt[-1]]
>>
<<3
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
p[0]['scopelist'] += [actRecordSt[-1]]
>>
<<4
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['scopelist'] = p[1]['scopelist'] + p[2]['scopelist']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
p[0]['scopelist'] += [actRecordSt[-1]]
>>

Operand : Literal
        | OperandName
        | MethodExpr
        | LPAREN Expression RPAREN
        | TRUE
        | FALSE
        | FuncCallStmt
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = [p[0]['place'] + ' := ' + p[1]['symbol']]
p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['code'] = p[1]['code'] + [p[0]['place'] + ' := ' + p[1]['place']]
p[0]['scopelist'] = p[1]['scopelist'] + [actRecordSt[-1]]
p[0]['type'] = p[1]['type']
>>
<<3
p[0]['type'] = 'Unknown'
>>
<<4
p[0]['type'] = p[2]['type']
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
p[0]['code'] += [p[0]['place'] + ' := ' + p[2]['place']]
p[0]['scopelist'] += [actRecordSt[-1]]
>>
<<5
p[0]['code'] = [p[0]['place'] + ' := true']
p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['type'] = 'bool'
>>
<<6
p[0]['code'] = [p[0]['place'] + ' := false']
p[0]['scopelist'] += [actRecordSt[-1]]
p[0]['type'] = 'bool'
>>
<<7
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
p[0]['type'] = ""
if len(p[1]['ret_types']) > 0:
  p[0]['type'] = p[1]['ret_types'][0]
>>

Literal : BasicLit
        | FunctionLit
<<1
p[0]['type'] = p[1]['type']
p[0]['symbol'] = p[1]['symbol']
>>

BasicLit  : INTEGERLIT
          | FLOATINGLIT
          | STRINGLIT
<<0
p[0]['symbol'] = p[1]
>>
<<1
p[0]['type'] = 'int'
>>
<<2
p[0]['type'] = 'float'
>>
<<3
p[0]['type'] = 'string'
>>

OperandName : IDENTIFIER
<<0
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ' := ' + p[1]]
#print(actRecordSt)
p[0]['scopelist'] = [actRecordSt[-1]]
p[0]['type'] = verifyCalType(p[1], p.lexer.lineno)
>>

FunctionLit : FUNC Function

MethodExpr  : ReceiverType DOT MethodName

ReceiverType  : TypeName
              | LPAREN MULT TypeName RPAREN
              | LPAREN ReceiverType RPAREN

Selector : DOT IDENTIFIER
<<0
p[0]['symbol'] = '.' + p[2]
>>

Index    : LSQUARE Expression RSQUARE
<<0
p[0]['symbol'] = '[' + p[2]['place'] + ']'
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

Arguments  : LPAREN ArgumentsHead RPAREN
<<0
p[0]['symbol'] = '(' + p[2]['symbol'] + ')'
p[0]['code'] = p[2]['code']
p[0]['scopelist'] = p[2]['scopelist']
>>

ArgumentsHead : ArgumentsHeadMid tripledotTop commaTop
              | empty
<<1
p[0]['symbol'] = p[1]['symbol'] + p[2]['symbol'] +p[3]['symbol']
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>

ArgumentsHeadMid  : ExpressionList
                  | Type COMMA ExpressionList
                  | Type
<<1
str = ''
for elt in p[1]['namelist'][:-1]:
    str += elt + ','
str += p[1]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[1]['code']
p[0]['scopelist'] = p[1]['scopelist']
>>
<<2
str = p[1]['place'] + ','
for elt in p[3]['namelist'][:-1]:
    str += elt + ','
str += p[3]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[3]['code']
p[0]['scopelist'] = p[3]['scopelist']
>>
<<3
p[0]['symbol'] = p[1]['place']
>>