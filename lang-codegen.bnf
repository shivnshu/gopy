keyword_lcurly : LCURLY
<<0
key = "sym#" + str(p.lexer.lineno) + "#" + str(p.lexer.lexpos)
symtab = SymbolTable(symTableDict[symTableSt[-1]], key)
symTableDict[key] = symtab
symTableSt += [key]
actRecord = ActivationRecord(key)
actRecordDict[key] = actRecord
actRecordSt += [actRecord.getName()]
>>

keyword_rcurly : RCURLY
<<0
sym_table = symTableDict[symTableSt[-1]]
act_record = actRecordDict[actRecordSt[-1]]
act_record.setLocalVarsInputArgs(sym_table)
symTableSt = symTableSt[:-1]
actRecordSt = actRecordSt[:-1]
>>

SourceFile  : PackageClause ImportDeclList TopLevelDeclList
<<0
for record_name in actRecordDict:
  if (record_name == "root"):
    continue
  actRecordDict[record_name].setGlobalVars(actRecordDict["root"].getGlobalVars())
  actRecordDict[record_name].setConstVars(actRecordDict["root"].getConstVars())
p[0]['dict_code'] = p[3]['dict_code']
print(symTableDict)
for key in symTableDict:
    symTableDict[key].prettyPrint()
print()
for key in actRecordDict:
    actRecordDict[key].prettyPrint()
print()
p[0]['activationRecords'] = actRecordDict
for key in p[0]['dict_code']:
  print(key + ":")
  for code in p[0]['dict_code'][key]:
    print(code)
  print()
>>

PackageClause  : PACKAGE IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
pkg = PackageEntry(p[2])
if (symTable.put(pkg) == False):
     print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
>>

ImportDeclList : ImportDecl ImportDeclList
               | empty

ImportDecl    : IMPORT ImportSpecTopList

ImportSpecTopList : ImportSpec
                  | LPAREN ImportSpecList RPAREN

ImportSpecList : ImportSpec ImportSpecList
               | empty

ImportSpec       :  ImportSpecInit ImportPath

ImportSpecInit : DOT
               | IDENTIFIER
               | empty

ImportPath     : STRINGLIT
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
name = p[1].replace('"', '')
entry = ImportEntry(name)
if (symTable.put(entry) == False):
     print("Error:", name, "redeclared on line number", p.lexer.lineno)
>>

TopLevelDeclList : TopLevelDecl TopLevelDeclList
                 | empty
<<1
#p[0]['dict_code'].update(p[1]['dict_code'])
#p[0]['dict_code'].update(p[2]['dict_code'])
final_dict_code = {}
for key in p[1]['dict_code']:
  if key in p[2]['dict_code']:
    final_dict_code[key] = p[1]['dict_code'][key] + p[2]['dict_code'][key]
  else:
    final_dict_code[key] = p[1]['dict_code'][key]
for key in p[2]['dict_code']:
  if not key in p[1]['dict_code']:
    final_dict_code[key] = p[2]['dict_code'][key]
p[0]['dict_code'] = final_dict_code
>>
<<2
sym_table = symTableDict[symTableSt[-1]]
act_record = actRecordDict[actRecordSt[-1]]
act_record.setLocalVarsInputArgs(sym_table)
act_record.setGlobalVars(act_record.getLocalVars())
>>

TopLevelDecl  : Declaration
              | FunctionDecl
              | MethodDecl
              | InterfaceDecl
              | IFuncDef
              | StructDef
<<0
p[0]['dict_code'] = {}
>>
<<1
p[0]['dict_code']['global_decl'] = code_optimization(p[1]['global_decl'])
p[0]['dict_code']['const_decl'] = code_optimization(p[1]['const_decl'])
>>
<<2
p[0]['dict_code'].update(p[1]['dict_code'])
>>
<<3
p[0]['dict_code'].update(p[1]['dict_code'])
>>

StructDef : TYPE IDENTIFIER STRUCT keyword_lcurly ParameterDeclList2 keyword_rcurly
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
struc = StructEntry(p[2])
if (symTable.put(struc) == False):
     print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
>>

ParameterDeclList2  : ParameterDecl2 ParameterDeclList2
                    | empty

ParameterDecl2  : IdentifierList1 Type

ParameterDecList2 : ParameterDecl2 ParameterDecList2
                  | empty

ParameterDecl2 : IdentifierList1 Type

InterfaceDecl : TYPE IDENTIFIER INTERFACE interfaceBlock
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
interfc = InterfaceEntry(p[2])
if (symTable.put(interfc) == False):
    print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
>>

interfaceBlock  : keyword_lcurly IFuncDecList keyword_rcurly

IFuncDecList   : IFuncDec IFuncDecList
               | empty

IFuncDec      : IDENTIFIER LPAREN RPAREN Type
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
if (symTable.put(fn) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
>>

IFuncDef      : FUNC LPAREN IDENTIFIER IDENTIFIER RPAREN IFuncDec Block

Block : keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['code'] = p[2]['code']
p[0]['ret_typelist'] = p[2]['ret_typelist']
>>

StatementList : Statement StatementList
              | empty
<<0
p[0]['ret_typelist'] = []
>>
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['ret_typelist'] = [p[1]['typelist']] + p[2]['ret_typelist']
>>

Statement : Declaration
          | SimpleStmt
          | ReturnStmt
          | Block
          | IfStmt
          | SwitchStmt
          | ForStmt
          | FuncCallStmt
          | GoFunc
<<0
p[0]['code'] = p[1]['code']
p[0]['typelist'] = []
>>
<<3
p[0]['typelist'] = p[1]['typelist']
>>
<<4
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<5
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<6
for typ in p[1]['ret_typelist']:
    p[0]['typelist'] += typ
>>
<<8
actRecordSt = actRecordSt[:-1]
>>

GoFunc    : GO FUNC Parameters FunctionBody LPAREN ExpressionList RPAREN
          | GO IDENTIFIER LPAREN ExpressionListBot RPAREN
<<1
code = ["start_go_func:"] + p[6]['code']
for id, value in zip(p[3]['idlist'], p[6]['namelist']):
    code += [id + " := " + value]
code += p[4]['code']
p[0]['code'] = code + ["end_go_func"]
>>
<<2
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[2])
if (symTable.put(fn) == False):
    print("Error:", p[2], "redeclared on line number", p.lexer.lineno)
>>

FuncCallStmt : IDENTIFIER DOT FuncCallStmt
             | IDENTIFIER DOT IDENTIFIER LPAREN ExpressionListBot RPAREN
             | IDENTIFIER DOT IDENTIFIER LPAREN ObjectMethod RPAREN
             | IDENTIFIER LPAREN ExpressionListBot RPAREN
<<0
p[0]['ret_types'] = []
p[0]['namelist'] = []
actRecordSt += ["root"]
>>
<<1
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Function", p[1], "not defined on line number", p.lexer.lineno)
p[0]['ret_types'] = p[3]['ret_types']
p[0]['code'] = p[3]['code']
>>
<<2
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Function", p[1], "not defined on line number", p.lexer.lineno)
p[0]['code'] = p[5]['code']
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_alloc 4"] # 4 for now
for param in p[5]['namelist'][::-1]:
    p[0]['code'] += ["push_param " + param]
p[0]['code'] += ["call " + p[1] + "." + p[3]]
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_param " + name]
>>
<<3
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Function", p[1], "not defined on line number", p.lexer.lineno)
>>
<<4
b = False
for scope in symTableSt:
  if p[1] in symTableDict[scope].symbols:
    b = True
    table = symTableDict[scope]
    break
if not b:
	print("Function", p[1], "not defined on line number", p.lexer.lineno)
entry = table.get(p[1])
p[0]['ret_types'] = entry.getReturnTypes()
actRecordSt[-1] = entry.getName()
for typ in p[0]['ret_types']:
  p[0]['namelist'] += [newVar()]
p[0]['code'] = p[3]['code']
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_alloc 4"] # 4 for now
for param in p[3]['namelist'][::-1]:
    p[0]['code'] += ["push_param " + param]
p[0]['code'] += ["call " + p[1]]
for name in p[0]['namelist']:
  p[0]['code'] += ["ret_param " + name]
if entry.getInputArgs() != p[3]['typelist']:
   print("Function", p[1], "arguments mismatch at line num", p.lexer.lineno)
>>

ObjectMethod : IDENTIFIER DOT IDENTIFIER LPAREN ParameterDeclList2 RPAREN

Declaration : ConstDecl
            | TypeDecl
            | VarDecl
<<0
p[0]['code'] = p[1]['code']
p[0]['const_decl'] = []
p[0]['global_decl'] = []
>>
<<1
p[0]['const_decl'] = p[1]['code']
>>
<<3
p[0]['global_decl'] = p[1]['code']
>>

ConstDecl  : CONST ConstSpecTopList
<<0
p[0]['code'] = p[2]['code']
>>

ConstSpecTopList : ConstSpec
                 | LPAREN ConstSpecList RPAREN
<<1
p[0]['code'] = p[1]['code']
>>
<<2
p[0]['code'] = p[2]['code']
>>

ConstSpecList : ConstSpec ConstSpecList
              | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

ConstSpec : IdentifierList1 ConstSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
actRecord = actRecordDict[actRecordSt[-1]]
if (len(p[1]['idlist']) != len(p[2]['namelist'])):
	print("Length mismatch on line number", p.lexer.lineno)
	return
p[0]['code'] = p[1]['code'] + p[2]['code']
for i,j,k in zip(p[1]['idlist'], p[2]['namelist'], p[2]['typelist']):
    p[0]['code'] += [i + ' := ' + j]
    actRecord.putConstVar(i)
    #var = VarEntry(i)
    #var.setType(k)
    #if (symTable.put(var) == False):
    #  print("Error:", i, "redeclared on line number", p.lexer.lineno)
>>

ConstSpecTail : TypeTop EQ ExpressionList
              | empty
<<1
p[0]['namelist'] = p[3]['namelist']
p[0]['typelist'] = p[3]['typelist']
p[0]['code'] = p[3]['code']
>>

TypeTop : Type
        | empty

IdentifierList1 : IDENTIFIER IdentifierBotList1
<<0
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierBotList1 :  IdentifierBotList1 COMMA IDENTIFIER
                  | empty
<<1
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

IdentifierList2 : IDENTIFIER IdentifierBotList2
<<0
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Error:", p[1], "not defined on line number", p.lexer.lineno)
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierList3 : IDENTIFIER IdentifierBotList3
<<0
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierBotList3 :  IdentifierBotList2 COMMA IDENTIFIER
                  | empty
<<0
p[0]['idlist'] = []
>>
<<1
p[0]['idlist'] = [p[3]] + p[1]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

IdentifierBotList2 :  IdentifierBotList2 COMMA IDENTIFIER
                  | empty
<<0
p[0]['idlist'] = []
>>
<<1
b = False
for scope in symTableSt:
	if p[3] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Error:", p[3], "not defined on line number", p.lexer.lineno)
p[0]['idlist'] = [p[3]] + p[1]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

IdOrArrayElemList : IdOrArrayElem IdOrArrayElemBotList
<<0
p[0]['idlist'] = [p[1]['id']] + p[2]['idlist']
p[0]['idxlists'] = [p[1]['idxlist']] + p[2]['idxlists']
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

IdOrArrayElemBotList : IdOrArrayElemBotList COMMA IdOrArrayElem
                      | empty
<<1
p[0]['idlist'] = p[1]['idlist'] + [p[3]['id']]
p[0]['idxlists'] = p[1]['idxlists'] + [p[3]['idxlist']]
p[0]['code'] = p[1]['code'] + p[3]['code']
>>
<<2
p[0]['idlist'] = []
p[0]['idxlists'] = []
>>

IdOrArrayElem : IDENTIFIER MoreDims
<<0
p[0]['id'] = p[1]
p[0]['idxlist'] = p[2]['idxlist']
p[0]['code'] = p[2]['code']
>>

MoreDims : LSQUARE Expression RSQUARE MoreDims
           | empty
<<1
p[0]['idxlist'] = [p[2]['place']] + p[4]['idxlist']
p[0]['code'] = p[2]['code'] + p[4]['code']
>>
<<2
p[0]['idxlist']  = []
>>

ExpressionList :  Expression ExpressionBotList
               |  FuncCallStmt ExpressionBotList
<<0
p[0]['code'] = p[1]['code'] + p[2]['code']
>>
<<1
p[0]['namelist'] = [p[1]['place']] + p[2]['namelist']
p[0]['typelist'] = [p[1]['type']] + p[2]['typelist']
>>
<<2
p[0]['namelist'] = p[1]['namelist'] + p[2]['namelist']
p[0]['typelist'] = p[1]['ret_types'] + p[2]['typelist']
actRecordSt = actRecordSt[:-1]
>>

ExpressionBotList : ExpressionBotList COMMA Expression
                  | empty
<<1
p[0]['namelist'] = p[1]['namelist'] + [p[3]['place']]
p[0]['typelist'] = p[1]['typelist'] + [p[3]['type']]
p[0]['code'] = p[1]['code'] + p[3]['code']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

TypeDecl : TYPE TypeSpecTopList

TypeSpecTopList : TypeSpec
                | LPAREN TypeSpecList  RPAREN

TypeSpecList : TypeSpec TypeSpecList SEMICOLON
             | empty

TypeSpec : AliasDecl
         | TypeDef

AliasDecl : IDENTIFIER EQ Type

TypeDef : IDENTIFIER Type
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
var = VarEntry(p[1])
if (symTable.put(var) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
>>

Type : TypeName
     | TypeLit
     | LPAREN Type RPAREN
<<1
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['type'] = p[1]['type']
>>
<<3
p[0]['type'] = p[2]['type']
>>

TypeName  : IDENTIFIER
          | QualifiedIdent
<<1
p[0]['type'] = p[1]
>>
<<2
p[0]['type'] = p[1]['type']
>>

QualifiedIdent : IDENTIFIER DOT IDENTIFIER
<<0
p[0]['type'] = verifyCalType(p[3], p.lexer.lineno)
>>

TypeLit  : ArrayType
         | StructType
         | FunctionType
<<0
p[0]['type'] = p[1]['type']
>>

ArrayType  : LSQUARE ArrayLength RSQUARE ElementType
<<0
if p[2]['type'] != "int" and p[2]['type'] != '':
	print("Array index error on line number", p.lexer.lineno)
p[0]['type'] = p[4]['type']
>>

ArrayLength : Expression
            | empty
<<1
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['type'] = ''
>>

ElementType : Type
<<0
p[0]['type'] = p[1]['type']
>>

StructType    : STRUCT keyword_lcurly FieldDeclList keyword_rcurly

FieldDeclList : FieldDecl FieldDeclList SEMICOLON
              | empty

FieldDecl  : FieldDeclHead TagTop

TagTop : Tag
       | empty

FieldDeclHead : IdentifierList1 Type
              | EmbeddedField

EmbeddedField : starTop TypeName

starTop : MULT
        | empty

Tag : STRINGLIT

FunctionType  : FUNC Signature

ResultTop : Result
          | empty
<<1
p[0]['ret_types'] = p[1]['ret_types']
>>
<<2
p[0]['ret_types'] = []
>>

Result   : Ret_Types
         | Type
<<1
p[0]['ret_types'] = p[1]['ret_types']
>>
<<2
p[0]['ret_types'] = [p[1]['type']]
>>

Ret_Types  : LPAREN TypeList RPAREN
<<0
p[0]['ret_types'] = p[2]['types']
>>

TypeList : Type TypeListBot
         | empty
<<1
p[0]['types'] = [p[1]['type']] + p[2]['types']
>>
<<2
p[0]['types'] = []
>>

TypeListBot : COMMA Type TypeListBot
          | empty
<<1
p[0]['types'] = [p[2]['type']] + p[3]['types']
>>
<<2
p[0]['types'] = []
>>

Parameters  : LPAREN ParameterListTop RPAREN
<<0
p[0]['args_types'] = p[2]['args_types']
p[0]['idlist'] = p[2]['idlist']
params = p[2]['idlist']
scope = symTableSt[-1]
for param,t in zip(params, p[0]['args_types']):
    entry = VarEntry(param)
    entry.setType(t)
    entry.isNotLocal()
    table = symTableDict[scope]
    if (table.put(entry) == False):
        print("Error:", param, "redeclared on line number", p.lexer.lineno)
>>

ParameterListTop : ParameterList commaTop
                 | empty
<<1
p[0]['args_types'] = p[1]['args_types']
p[0]['idlist'] = p[1]['idlist']
>>
<<2
p[0]['args_types'] = []
p[0]['idlist'] = []
>>

commaTop : COMMA
         | empty

ParameterList  : ParameterDecl ParameterDeclList
<<0
p[0]['args_types'] = [p[1]['type']] + p[2]['args_types']
p[0]['idlist'] = p[1]['idlist'] + p[2]['idlist']
>>

ParameterDeclList : COMMA ParameterDecl ParameterDeclList
                  | empty
<<1
p[0]['args_types'] = [p[2]['type']] + p[3]['args_types']
p[0]['idlist'] = p[2]['idlist'] + p[3]['idlist']
>>
<<2
p[0]['args_types'] = []
p[0]['idlist'] = []
>>

ParameterDecl  : ParameterDeclHead tripledotTop Type
<<0
p[0]['type'] = p[3]['type']
p[0]['idlist'] = p[1]['idlist']
>>

tripledotTop : DOT_DOT_DOT
             | empty
<<1
p[0]['symbol'] = '...'
>>
<<2
p[0]['symbol'] = ''
>>

ParameterDeclHead : IdentifierList1
                  | empty
<<1
p[0]['idlist'] = p[1]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

VarDecl : VAR VarSpecTopList
<<0
p[0]['code'] = p[2]['code']
>>

VarSpecTopList : VarSpec
               | LPAREN VarSpecList RPAREN
<<1
p[0]['code'] = p[1]['code']
>>
<<2
p[0]['code'] = p[2]['code']
>>

VarSpecList : VarSpec VarSpecList SEMICOLON
            | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

VarSpec  : IdentifierList1 VarSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
if ((p[2]['type_used'] == False) and  len(p[1]['idlist']) != len(p[2]['namelist'])):
	print("Length mismatch on line number", p.lexer.lineno)
	return
p[0]['code'] = p[1]['code'] + p[2]['code']
mylist = p[1]['idlist']
mytypelist = p[2]['typelist']
for index in range(len(mylist)):
    i = mylist[index]
    var = VarEntry(i)
    if (p[2]['type_used'] == False):
      var.setType(mytypelist[index])
    else:
      var.setType(p[2]['typelist'][0])
    if (symTable.put(var) == False):
        print("Error:", i, "redeclared on line number", p.lexer.lineno)
    if (len(p[2]['namelist']) != 0):
      j = p[2]['namelist'][index]
      p[0]['code'] += [i + " := " + j] 
>>

VarSpecTail : Type VarSpecMid
            | EQ ExpressionList
<<0
p[0]['namelist'] = p[2]['namelist']
p[0]['code'] = p[2]['code']
>>
<<1
p[0]['typelist'] = [p[1]['type']]
p[0]['type_used'] = True
>>
<<2
p[0]['typelist'] = p[2]['typelist']
p[0]['type_used'] = False
>>

VarSpecMid : EQ ExpressionList
           | empty
<<1
p[0]['namelist'] = p[2]['namelist']
p[0]['typelist'] = p[2]['typelist']
p[0]['code'] = p[2]['code']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

FunctionDecl : FUNC Signature FunctionBodyTop
<<0
this_func_sym_table = symTableDict[symTableSt[-1]]
act_record = actRecordDict[actRecordSt[-1]]
actRecordSt = actRecordSt[:-1]
symTableSt = symTableSt[:-1]
input_args = p[2]['input_args']
ret_types = p[2]['ret_types']
func_name = p[2]['func_name']
scope = symTableSt[-1]
table = symTableDict[scope]
entry = symTableDict[symTableSt[-1]].get(func_name)
act_record.setLocalVarsInputArgs(this_func_sym_table)
#act_record.storeOldStPtr("%rbp")
act_record.setRetValues(entry)
p[0]['dict_code'] = { func_name: code_optimization(p[3]['code']) }
for ret_actual in p[3]['ret_actual_types']:
      if (len(ret_actual) > 0 and p[2]['ret_types'] != ret_actual):
           print("Error:", func_name, "return types mismatch on line number", p.lexer.lineno)
>>

Signature  : FunctionName Parameters ResultTop
<<0
func_name = p[1]['func_name']
p[0]['input_args'] = p[2]['args_types']
p[0]['ret_types'] = p[3]['ret_types']
p[0]['func_name'] = func_name
entry = symTableDict[symTableSt[-2]].get(func_name)
entry.setInputArgs(p[0]['input_args'])
entry.setReturnTypes(p[0]['ret_types'])
>>

FunctionBodyTop : FunctionBody
                | empty
<<0
p[0]['ret_actual_types'] = []
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['ret_actual_types'] = p[1]['ret_typelist']
>>

FunctionDeclTail : Function
                 | Signature
<<0
p[0]['code'] = p[1]['code']
p[0]['input_args'] = p[1]['input_args']
p[0]['ret_types'] = p[1]['ret_types']
p[0]['ret_actual_types'] = []
>>
<<1
p[0]['ret_actual_types'] = p[1]['ret_actual_types']
>>

FunctionName : IDENTIFIER
<<0
table = symTableDict[symTableSt[-1]]
entry = FuncEntry(p[1])
if (table.put(entry) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
p[0]['func_name'] = p[1]
key = "sym#" + str(p.lexer.lineno) + "#" + str(p.lexer.lexpos)
symtab = SymbolTable(symTableDict[symTableSt[-1]], key)
symTableDict[key] = symtab
symTableSt += [key]
actRecord = ActivationRecord(p[1])
actRecordDict[p[1]] = actRecord
actRecordSt += [actRecord.getName()]
>>

Function  : Signature FunctionBody
<<0
p[0]['code'] = p[2]['code']
p[0]['input_args'] = p[1]['input_args']
p[0]['ret_types'] = p[1]['ret_types']
p[0]['ret_actual_types'] = p[2]['ret_typelist']
>>

FunctionBody : LCURLY StatementList RCURLY
<<0
p[0]['code'] = p[2]['code']
p[0]['ret_typelist'] = p[2]['ret_typelist']
>>

MethodDecl : FUNC Receiver MethodName FunctionDeclTail
<<0
p[0]['dict_code'] = { p[3]: code_optimization(p[4]['code']) }
>>

MethodName : IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
if (symTable.put(fn) == False):
    print("Error:", p[1], "redeclared on line number", p.lexer.lineno)
>>

Receiver  : Parameters

SimpleStmt : ExpressionStmt
           | Assignment
           | AssignmentGen
           | ShortVarDecl
<<0
p[0]['code'] = p[1]['code']
p[0]['place'] = ''
>>
<<1
p[0]['place'] = p[1]['place']
>>

ExpressionStmt : Expression
<<0
p[0]['code'] = p[1]['code']
p[0]['place'] = p[1]['place']
>>

ShortVarDecl : IdentifierList3 SHORT_ASSIGN ExpressionList
<<0
scope = symTableSt[-1]
table = symTableDict[scope]
p[0]['code'] = p[1]['code'] + p[3]['code']
if (len(p[1]['idlist']) != len(p[3]['namelist'])):
   print("Left and right side not equal on line number", p.lexer.lineno)
for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
  p[0]['code'] += [i + ' := ' + j]
  entry = VarEntry(i)
  if (table.put(entry) == False):
     print("Error:", i, "redeclared on line number", p.lexer.lineno)
  entry.setType(k)
>>

Assignment : IdentifierList2 assign_op ExpressionList
<<0
p[0]['code'] = p[1]['code'] + p[3]['code']
if (p[2]['len'] == 1):
  for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
    if verifyCalType(i, p.lexer.lineno) != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +verifyCalType(i, p.lexer.lineno)+", got type "+ k)
    p[0]['code'] += [i + ' := ' + j] 
else:
  for i, j, k in zip(p[1]['idlist'], p[3]['namelist'], p[3]['typelist']):
    if verifyCalType(i, p.lexer.lineno) != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +verifyCalType(i, p.lexer.lineno)+", got type "+ k)
    p[0]['code'] += [i + ' :=  '+ i + p[2]['symbol'] + j]
>>

AssignmentGen : IdOrArrayElemList assign_op ExpressionList
<<0
p[0]['code'] = p[1]['code'] + p[3]['code']
if (p[2]['len'] == 1):
  for i, idx,  j, k in zip(p[1]['idlist'], p[1]['idxlists'],  p[3]['namelist'], p[3]['typelist']):
    if verifyCalType(i, p.lexer.lineno) != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +verifyCalType(i, p.lexer.lineno)+", got type "+ k)
    if (len(idx) == 0):
      idx = ""
    p[0]['code'] += [i + str(idx) + ' := ' + j] 
else:
  for i, idx, j, k in zip(p[1]['idlist'], p[1]['idxlists'], p[3]['namelist'], p[3]['typelist']):
    if verifyCalType(i, p.lexer.lineno) != k:
      print("Error type mismatch in line " +str(p.lexer.lineno) +". Expected type " +verifyCalType(i, p.lexer.lineno)+", got type "+ k)
    if (len(idx) == 0):
      idx = ""
    p[0]['code'] += [i + str(idx) + ' := ' + i + str(idx) + p[2]['symbol'] + j]
>>

assign_op : addmul_op EQ
<<0
p[0]['len'] = 1 + p[1]['len']
p[0]['symbol'] = p[1]['symbol']
>>

addmul_op : add_op
          | mul_op
          | empty
<<1
p[0]['len'] = 1
p[0]['symbol'] = p[1]['symbol']
>>
<<2
p[0]['len'] = 1
p[0]['symbol'] = p[1]['symbol']
>>
<<3
p[0]['len'] = 0
p[0]['symbol'] = ''
>>

IfStmt : IF SimpleStmtBot ExpressionBot Block elseBot
<<0
p[0]['lastlabel'] = p[5]['lastlabel']
p[4]['label'] = newLabel()
if (p[2]['place'] == ''):
   print("Inadequate condition at line num", p.lexer.lineno)
if (p[5]['symbol'] != ""):
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " " +p[5]['symbol']]
else:
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " else goto " +p[0]['lastlabel']]
   
p[0]['code'] += [p[4]['label'] + ':'] + p[4]['code'] + ["goto " + p[0]['lastlabel']]
p[0]['code'] += p[5]['code'] + [p[0]['lastlabel'] +": "]
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

IfStmt2 : IF SimpleStmtBot ExpressionBot Block elseBot
<<0
p[0]['lastlabel'] = p[5]['lastlabel']
p[4]['label'] = newLabel()
if (p[2]['place'] == ''):
   print("Inadequate condition at line num", p.lexer.lineno)
if (p[5]['symbol'] != ""):
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " " +p[5]['symbol']]
else:
   p[0]['code'] = p[2]['code'] + ['if '+ p[2]['place'] + p[3]['symbol'] + ' goto ' + p[4]['label'] + " else goto " +p[0]['lastlabel']]
   
p[0]['code'] += [p[4]['label'] + ':'] + p[4]['code'] + ["goto " + p[0]['lastlabel']]
p[0]['code'] += p[5]['code']
p[0]['ret_typelist'] = p[4]['ret_typelist']
print(p[0]['code'])
>>

SimpleStmtBot : SimpleStmt
              | TRUE
              | FALSE
              | empty
<<0
p[0]['code'] = []
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['place'] = p[1]['place']
>>
<<2
p[1]['place'] = 'true'
>>
<<3
p[0]['place'] = 'false'
>>
<<4
p[0]['place'] = ''
>>

elseBot : ELSE elseTail
        | empty
<<1
p[2]['label'] = newLabel()
p[0]['symbol'] = 'else goto ' + p[2]['label']
p[0]['code'] = [p[2]['label'] + ' : '] + p[2]['code']
p[0]['lastlabel'] = p[2]['lastlabel']
>>
<<2
p[0]['symbol'] = ''
p[0]['code'] = []
p[0]['lastlabel'] = newLabel()
>>

elseTail : IfStmt2
         | Block
<<0
p[0]['code'] = p[1]['code']
>>
<<1
p[0]['lastlabel'] = p[1]['lastlabel']
>>
<<2
p[0]['lastlabel'] = newLabel()
>>

SwitchStmt : ExprSwitchStmt
<<0
p[0]['code'] = p[1]['code']
p[0]['ret_typelist'] = p[1]['ret_typelist']
>>

ExprSwitchStmt : SWITCH IDENTIFIER keyword_lcurly ExprCaseClauseList keyword_rcurly
<<0
b = False
for scope in symTableSt:
	if p[2] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Switch variable", p[2], "not declared on line number", p.lexer.lineno)
p[0]['code'] = p[4]['expcodelist']
for exp, label in zip(p[4]['explist'], p[4]['labellist'][:-1]):
	p[0]['code'] += ['if ' + p[2] + ' == ' + exp + ' goto ' + label]
for label, codeblock in zip(p[4]['labellist'][:-1], p[4]['code']):
	p[0]['code'] += codeblock
	p[0]['code'] += ['goto ' + p[4]['labellist'][-1]]
p[0]['code'] += [p[4]['labellist'][-1] + ':']
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

ExprCaseClauseList : ExprCaseClause ExprCaseClauseList
                   | empty
<<1
p[0]['explist'] = [p[1]['exp']] + p[2]['explist']
p[0]['expcodelist'] = p[1]['expcode'] + p[2]['expcodelist']
p[0]['labellist'] = [p[1]['label']] + p[2]['labellist']
p[0]['code'] = [p[1]['code']] + p[2]['code']
p[0]['ret_typelist'] = [p[1]['ret_typelist']] + p[2]['ret_typelist']
>>
<<2
p[0]['explist'] = []
p[0]['expcodelist'] = []
p[0]['labellist'] = [newLabel()]
p[0]['code'] = []
p[0]['ret_typelist'] = []
>>

ExprCaseClause : ExprSwitchCase COLON keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['exp'] = p[1]['exp']
p[0]['expcode'] = p[1]['code']
p[0]['label'] = newLabel()
p[0]['code'] = [p[0]['label'] + ' : '] + p[4]['code']
p[0]['ret_typelist'] = p[4]['ret_typelist']
>>

ExprSwitchCase : CASE Expression
               | DEFAULT
<<1
p[0]['exp'] = p[2]['place']
p[0]['code'] = p[2]['code']
>>

ForStmt : FOR ExpressionBot Block

ExpressionBot : Expression
              | empty
<<1
p[0]['symbol'] = p[1]['code'][-1] 
>>
<<2
p[0]['symbol'] = ''
>>

ReturnStmt : RETURN ExpressionListBot
<<0
p[0]['typelist'] = p[2]['typelist']
p[0]['code'] = p[2]['code']
for name in p[2]['namelist']:
      p[0]['code'] += ["ret " + name]
>>

ExpressionListBot : ExpressionList
                  | empty
<<1
p[0]['code'] = p[1]['code']
p[0]['typelist'] = p[1]['typelist']
p[0]['namelist'] = p[1]['namelist']
>>
<<2
p[0]['typelist'] = []
p[0]['namelist'] = []
>>

Expression : UnaryExpr
           | Expression binary_op Expression
           | IDENTIFIER DOT IDENTIFIER
           | IDENTIFIER keyword_lcurly ObjectParamList keyword_rcurly
<<0
p[0]['type'] = ''
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['type'] = p[1]['type']
p[0]['place'] = p[1]['place']
>>
<<2
p[0]['place'] = newVar()
if p[1]['type'] == p[3]['type']:
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := ' + p[1]['place'] +" "+ p[2]['symbol'] + p[1]['type']+" " + p[3]['place']]
  p[0]['type'] = p[1]['type']
elif (p[1]['type']=='float' and p[3]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-float ' + p[1]['place']+" " + p[2]['symbol'] + 'float ' + p[3]['place']]
  p[0]['type'] ='float'
elif (p[3]['type']=='float' and p[1]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-float ' + p[3]['place'] +" "+ p[2]['symbol'] + 'float ' + p[1]['place']]
  p[0]['type'] ='float'
elif (p[1]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-string ' + p[3]['place'] +" "+ p[2]['symbol'] + 'string ' + p[1]['place']]
  p[0]['type'] ='string'
elif (p[3]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ' := cast-to-string ' + p[1]['place'] +" "+ p[2]['symbol'] + 'string ' + p[3]['place']]
  p[0]['type'] ='string'
>>
<<3
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ' := ' + p[1]['place'] + '.' + p[2]['place']]
>>

ObjectParamList : ObjectParam ObjectParamTop

ObjectParamTop : COMMA ObjectParamTop
               | COMMA ObjectParam
               | empty

ObjectParam   : IDENTIFIER COLON Expression

UnaryExpr  : PrimaryExpr
           | unary_op UnaryExpr
<<1
p[0]['place'] = p[1]['place']
p[0]['type'] = p[1]['type']
p[0]['code'] = p[1]['code']
>>
<<2
p[0]['place'] = newVar()
p[0]['type'] = p[2]['type']
p[0]['code'] = p[2]['code'] + [p[0]['place'] + ' := ' + p[1]['symbol'] + p[2]['place']]
>>

binary_op  : OR_OR
           | AND_AND
           | rel_op
           | add_op
           | mul_op
<<1
p[0]['symbol'] = p[1]
>>
<<2
p[0]['symbol'] = p[1]
>>
<<3
p[0]['symbol'] = p[1]['symbol']
>>
<<4
p[0]['symbol'] = p[1]['symbol']
>>
<<5
p[0]['symbol'] = p[1]['symbol']
>>

rel_op  : EQ_EQ
        | NOT_EQ
        | LESS
        | LESS_EQ
        | GREATER
        | GREATER_EQ
<<0
p[0]['symbol'] = p[1]
>>

add_op  : ADD
        | MINUS
        | OR
        | POW
<<0
p[0]['symbol'] = p[1]
>>

mul_op  : MULT
        | DIV
        | LSHIFT
        | RSHIFT
        		        | AND
        | AND_POW
<<0
p[0]['symbol'] = p[1]
>>

unary_op  : ADD
          | MINUS
          | NOT
          | POW
          | MULT
          | AND
          | RECEIVE
<<0
p[0]['symbol'] = p[1]
>>

PrimaryExpr : Operand
            | PrimaryExpr Selector
            | PrimaryExpr Index
            | PrimaryExpr Arguments
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place']]
>>
<<2
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
>>
<<3
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
>>
<<4
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ' := ' + p[1]['place'] + p[2]['symbol']]
>>

Operand : Literal
        | OperandName
        | MethodExpr
        | LPAREN Expression RPAREN
        | TRUE
        | FALSE
        | FuncCallStmt
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = [p[0]['place'] + ' := ' + p[1]['symbol']]
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['code'] = p[1]['code'] + [p[0]['place'] + ' := ' + p[1]['place']]
p[0]['type'] = p[1]['type']
>>
<<4
p[0]['type'] = p[2]['type']
p[0]['code'] = p[2]['code']
p[0]['code'] += [p[0]['place'] + ' := ' + p[2]['place']]
>>
<<5
p[0]['code'] = [p[0]['place'] + ' := true']
p[0]['type'] = 'bool'
>>
<<6
p[0]['code'] = [p[0]['place'] + ' := false']
p[0]['type'] = 'bool'
>>
<<7
p[0]['code'] = p[1]['code']
p[0]['type'] = ""
if len(p[1]['ret_types']) > 0:
  p[0]['type'] = p[1]['ret_types'][0]
>>

Literal : BasicLit
        | FunctionLit
<<1
p[0]['type'] = p[1]['type']
p[0]['symbol'] = p[1]['symbol']
>>

BasicLit  : INTEGERLIT
          | FLOATINGLIT
          | STRINGLIT
<<0
p[0]['symbol'] = p[1]
>>
<<1
p[0]['type'] = 'int'
>>
<<2
p[0]['type'] = 'float'
>>
<<3
p[0]['type'] = 'string'
>>

OperandName : IDENTIFIER
<<0
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ' := ' + p[1]]
p[0]['type'] = verifyCalType(p[1], p.lexer.lineno)
>>

FunctionLit : FUNC Function

MethodExpr  : ReceiverType DOT MethodName

ReceiverType  : TypeName
              | LPAREN MULT TypeName RPAREN
              | LPAREN ReceiverType RPAREN

Selector : DOT IDENTIFIER
<<0
p[0]['symbol'] = '.' + p[2]
>>

Index    : LSQUARE Expression RSQUARE
<<0
p[0]['symbol'] = '[' + p[2]['place'] + ']'
p[0]['code'] = p[2]['code']
>>

Arguments  : LPAREN ArgumentsHead RPAREN
<<0
p[0]['symbol'] = '(' + p[2]['symbol'] + ')'
p[0]['code'] = p[2]['code']
>>

ArgumentsHead : ArgumentsHeadMid tripledotTop commaTop
              | empty
<<1
p[0]['symbol'] = p[1]['symbol'] + p[2]['symbol'] +p[3]['symbol']
p[0]['code'] = p[1]['code']
>>

ArgumentsHeadMid  : ExpressionList
                  | Type COMMA ExpressionList
                  | Type
<<1
str = ''
for elt in p[1]['namelist'][:-1]:
    str += elt + ','
str += p[1]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[1]['code']
>>
<<2
str = p[1]['place'] + ','
for elt in p[3]['namelist'][:-1]:
    str += elt + ','
str += p[3]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[3]['code']
>>
<<3
p[0]['symbol'] = p[1]['place']
>>