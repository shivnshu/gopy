keyword_lcurly : LCURLY
<<0
key = "sym#" + str(p.lexer.lineno) + "#" + str(p.lexer.lexpos)
symtab = SymbolTable(symTableSt[-1], key)
symTableDict[key] = symtab
symTableSt += [key]
>>

keyword_rcurly : RCURLY
<<0
symTableSt = symTableSt[:-1]
>>

SourceFile  : PackageClause ImportDeclList TopLevelDeclList
<<0
print(symTableDict)
for key in symTableDict:
    symTableDict[key].prettyPrint()
p[0]['code'] = p[1]['code'] + p[2]['code'] + p[3]['code']
>>

PackageClause  : PACKAGE IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
pkg = PackageEntry(p[2])
symTable.put(pkg)
>>

ImportDeclList : ImportDecl ImportDeclList
               | empty

ImportDecl    : IMPORT ImportSpecTopList

ImportSpecTopList : ImportSpec
                  | LPAREN ImportSpecList RPAREN

ImportSpecList : ImportSpec ImportSpecList
               | empty

ImportSpec       :  ImportSpecInit ImportPath

ImportSpecInit : DOT
               | IDENTIFIER
               | empty

ImportPath     : STRINGLIT
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
entry = ImportEntry(p[1])
symTable.put(entry)
>>

TopLevelDeclList : TopLevelDecl TopLevelDeclList
                 | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

TopLevelDecl  : Declaration
              | FunctionDecl
              | MethodDecl
              | InterfaceDecl
              | IFuncDef
              | StructDef
<<0
p[0]['code'] = p[1]['code']
>>

StructDef : TYPE IDENTIFIER STRUCT keyword_lcurly ParameterDeclList2 keyword_rcurly
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
struc = StructEntry(p[2])
symTable.put(struc)
>>

ParameterDeclList2  : ParameterDecl2 ParameterDeclList2
                    | empty

ParameterDecl2  : IdentifierList1 Type

ParameterDecList2 : ParameterDecl2 ParameterDecList2
                  | empty

ParameterDecl2 : IdentifierList1 Type

InterfaceDecl : TYPE IDENTIFIER INTERFACE interfaceBlock
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
interfc = InterfaceEntry(p[2])
symTable.put(interfc)
>>

interfaceBlock  : keyword_lcurly IFuncDecList keyword_rcurly

IFuncDecList   : IFuncDec IFuncDecList
               | empty

IFuncDec      : IDENTIFIER LPAREN RPAREN Type
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
symTable.put(fn)
>>

IFuncDef      : FUNC LPAREN IDENTIFIER IDENTIFIER RPAREN IFuncDec Block

Block : keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['code'] = p[2]['code']
>>

StatementList : Statement StatementList
              | empty
<<1
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

Statement : Declaration
          | SimpleStmt
          | ReturnStmt
          | Block
          | IfStmt
          | SwitchStmt
          | ForStmt
          | FuncCallStmt
          | GoFunc
<<0
p[0]['code'] = p[1]['code']
>>

GoFunc    : GO FUNC Parameters FunctionBody LPAREN ExpressionList RPAREN
          | GO IDENTIFIER LPAREN ExpressionListBot RPAREN
<<2
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[2])
symTable.put(fn)
>>

FuncCallStmt : IDENTIFIER DOT FuncCallStmt
             | IDENTIFIER DOT FunctionName LPAREN RPAREN
             | IDENTIFIER DOT FunctionName LPAREN ExpressionList RPAREN
             | IDENTIFIER DOT FunctionName LPAREN ObjectMethod RPAREN
<<0
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols[::-1]:
		b = True
		break
if not b:
	print("Function", p[1], "not defined on line number", p.lexer.lineno)
>>

ObjectMethod : IDENTIFIER DOT IDENTIFIER LPAREN ParameterDeclList2 RPAREN

Declaration : ConstDecl
            | TypeDecl
            | VarDecl
<<0
p[0]['code'] = p[1]['code']
>>

ConstDecl  : CONST ConstSpecTopList

ConstSpecTopList : ConstSpec
                 | LPAREN ConstSpecList RPAREN

ConstSpecList : ConstSpec ConstSpecList
              | empty

ConstSpec : IdentifierList1 ConstSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
if (len(p[1]['idlist']) != len(p[2]['namelist'])):
	print("Length mismatch on line number", p.lexer.lineno)
	return
p[0]['code'] = p[1]['code'] + p[2]['code']
for i,j,k in zip(p[1]['idlist'], p[2]['namelist'], p[2]['typelist']):
	p[0]['code'] += [i + ' := ' + j]
	var = VarEntry(i)
	var.setType(k)
	symTable.put(var)
>>

ConstSpecTail : TypeTop EQ ExpressionList
              | empty
<<1
p[0]['namelist'] = p[3]['namelist']
p[0]['typelist'] = p[3]['typelist']
>>

TypeTop : Type
        | empty

IdentifierList1 : IDENTIFIER IdentifierBotList1
<<0
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierBotList1 :  IdentifierBotList1 COMMA IDENTIFIER
                  | empty
<<1
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

IdentifierList2 : IDENTIFIER IdentifierBotList2
<<0
b = False
for scope in symTableSt:
	if p[1] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Error:", p[1], "not defined on line number", p.lexer.lineno)
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierList3 : IDENTIFIER IdentifierBotList2
<<0
p[0]['idlist'] = [p[1]] + p[2]['idlist']
>>

IdentifierBotList2 :  IdentifierBotList2 COMMA IDENTIFIER
                  | empty
<<0
p[0]['idlist'] = []
>>
<<1
b = False
for scope in symTableSt:
	if p[3] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Error:", p[3], "not defined on line number", p.lexer.lineno)
p[0]['idlist'] = [p[3]] + p[1]['idlist']
>>
<<2
p[0]['idlist'] = []
>>

ExpressionList :  Expression ExpressionBotList
<<0
p[0]['namelist'] = [p[1]['place']] + p[2]['namelist']
p[0]['typelist'] = [p[1]['type']] + p[2]['typelist']
p[0]['code'] = p[1]['code'] + p[2]['code']
>>

ExpressionBotList : ExpressionBotList COMMA Expression
                  | empty
<<1
p[0]['namelist'] = [p[3]['place']] + p[1]['namelist']
p[0]['typelist'] = [p[3]['type']] + p[1]['typelist']
p[0]['code'] = p[1]['code'] + p[3]['code']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

TypeDecl : TYPE TypeSpecTopList

TypeSpecTopList : TypeSpec
                | LPAREN TypeSpecList  RPAREN

TypeSpecList : TypeSpec TypeSpecList SEMICOLON
             | empty

TypeSpec : AliasDecl
         | TypeDef

AliasDecl : IDENTIFIER EQ Type

TypeDef : IDENTIFIER Type
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
var = VarEntry(p[1])
symTable.put(var)
>>

Type : TypeName
     | TypeLit
     | LPAREN Type RPAREN
<<1
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['type'] = p[1]['type']
>>
<<3
p[0]['type'] = p[2]['type']
>>

TypeName  : IDENTIFIER
          | QualifiedIdent
<<1
p[0]['type'] = p[1]
>>
<<2
p[0]['type'] = p[1]['type']
>>

QualifiedIdent : IDENTIFIER DOT IDENTIFIER
<<0
p[0]['type'] = verifyCalType(p[3], p.lexer.lineno)
>>

TypeLit  : ArrayType
         | StructType
         | FunctionType

ArrayType  : LSQUARE ArrayLength RSQUARE ElementType
<<0
if p[2]['type'] != "int" and p[2]['type'] != '':
	print("Array index error on line number", p.lexer.lineno)
>>

ArrayLength : Expression
            | empty
<<1
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['type'] = ''
>>

ElementType : Type

StructType    : STRUCT keyword_lcurly FieldDeclList keyword_rcurly

FieldDeclList : FieldDecl FieldDeclList SEMICOLON
              | empty

FieldDecl  : FieldDeclHead TagTop

TagTop : Tag
       | empty

FieldDeclHead : IdentifierList1 Type
              | EmbeddedField

EmbeddedField : starTop TypeName

starTop : MULT
        | empty

Tag : STRINGLIT

FunctionType  : FUNC Signature

Signature  : Parameters ResultTop

ResultTop : Result
          | empty

Result   : Parameters
         | Type

Parameters  : LPAREN ParameterListTop RPAREN

ParameterListTop : ParameterList commaTop
                 | empty

commaTop : COMMA
         | empty

ParameterList  : ParameterDecl ParameterDeclList

ParameterDeclList : COMMA ParameterDecl ParameterDeclList
                  | empty

ParameterDecl  : ParameterDeclHead tripledotTop Type

tripledotTop : DOT_DOT_DOT
             | empty
<<1
p[0]['symbol'] = '...'
>>
<<2
p[0]['symbol'] = ''
>>

ParameterDeclHead : IdentifierList1
                  | empty

VarDecl : VAR VarSpecTopList

VarSpecTopList : VarSpec
               | LPAREN VarSpecList RPAREN

VarSpecList : VarSpec VarSpecList SEMICOLON
            | empty

VarSpec  : IdentifierList1 VarSpecTail
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
if ((p[2]['type_used'] == False) and  len(p[1]['idlist']) != len(p[2]['namelist'])):
	print("Length mismatch on line number", p.lexer.lineno)
	return
p[0]['code'] = p[1]['code'] + p[2]['code']
mylist = p[1]['idlist']
mytypelist = p[2]['typelist']
for index in range(len(mylist)):
	i = mylist[index]
	var = VarEntry(i)
	if (p[2]['type_used'] == False):
		var.setType(mytypelist[index])
	else:
		var.setType(p[2]['typelist'][0])
	symTable.put(var)
>>

VarSpecTail : Type VarSpecMid
            | EQ ExpressionList
<<0
p[0]['namelist'] = p[2]['namelist']
>>
<<1
p[0]['typelist'] = [p[1]['type']]
p[0]['type_used'] = True
>>
<<2
p[0]['typelist'] = p[2]['typelist']
p[0]['type_used'] = False
>>

VarSpecMid : EQ ExpressionList
           | empty
<<1
p[0]['namelist'] = p[2]['namelist']
p[0]['typelist'] = p[2]['typelist']
>>
<<2
p[0]['namelist'] = []
p[0]['typelist'] = []
>>

FunctionDecl : FUNC FunctionName FunctionDeclTail
<<0
p[0]['code'] = p[3]['code']
>>

FunctionDeclTail : Function
                 | Signature
<<0
p[0]['code'] = p[1]['code']
>>

FunctionName : IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
symTable.put(fn)
>>

Function  : Signature FunctionBody
<<0
p[0]['code'] = p[2]['code']
>>

FunctionBody : Block
<<0
p[0]['code'] = p[1]['code']
>>

MethodDecl : FUNC Receiver MethodName FunctionDeclTail
<<0
p[0]['code'] = p[4]['code']
>>

MethodName : IDENTIFIER
<<0
scope = symTableSt[-1]
symTable = symTableDict[scope]
fn = FuncEntry(p[1])
symTable.put(fn)
>>

Receiver  : Parameters

SimpleStmt : ExpressionStmt
           | Assignment
           | ShortVarDecl
<<0
p[0]['code'] = p[1]['code']
>>

ExpressionStmt : Expression
<<0
p[0]['code'] = p[1]['code']
>>

ShortVarDecl : IdentifierList3 SHORT_ASSIGN ExpressionList
<<0
p[0]['code'] = p[1]['code'] + p[3]['code']
for i, j in zip(p[1]['idlist'], p[3]['namelist']):
  p[0]['code'] += [i + ' := ' + j]
>>

Assignment : IdentifierList2 assign_op ExpressionList
<<0
p[0]['code'] = p[1]['code'] + p[3]['code']
if (p[2]['len'] == 1):
  for i, j in zip(p[1]['idlist'], p[3]['namelist']):
    p[0]['code'] += [i + ' := ' + j]
else:
  for i, j in zip(p[1]['idlist'], p[3]['namelist']):
    p[0]['code'] += [i + ' :=  i '+p2['symbol'] + j]
>>

assign_op : addmul_op EQ
<<0
p[0]['len'] = 1 + p[1]['len']
p[0]['symbol'] = p[1]['symbol']
>>

addmul_op : add_op
          | mul_op
          | empty
<<1
p[0]['len'] = 1
p[0][symbol] = p[1][symbol]
>>
<<2
p[0]['len'] = 1
p[0]['symbol'] = p[1]['symbol']
>>
<<3
p[0]['len'] = 0
p[0]['symbol'] = ''
>>

IfStmt : IF SimpleStmtBot ExpressionBot Block elseBot
<<0
p[4]['label'] = newLabel()
p[0]['code'] = ['if '+ p[2]['symbol'] + p[3]['symbol'] + ' goto ' + p[4]['label'] +p[5]['symbol']]
p[0]['code'] += [p[4]['label'] + ':'] + p[4]['code']
p[0]['code'] += p[5]['code']
>>

SimpleStmtBot : SimpleStmt
              | TRUE
              | FALSE
              | empty
<<1
p[0]['symbol'] = p[1]['code'][-1]
>>
<<2
p[0]['symbol'] = 'true'
>>
<<3
p[0]['symbol'] = 'false'
>>
<<4
p[0]['symbol'] = ''
>>

elseBot : ELSE elseTail
        | empty
<<1
p[2]['label'] = newLabel()
p[0]['symbol'] = 'else goto ' + p[2]['label']
p[0]['code'] = [p[2]['label'] + ' : '] + p[2]['code']
>>
<<2
p[0]['symbol'] = ''
p[0]['code'] = []
>>


elseTail : IfStmt
         | Block
<<0
p[0]['code'] = p[1]['code']
>>

SwitchStmt : ExprSwitchStmt
<<0
p[0]['code'] = p[1]['code']
>>

ExprSwitchStmt : SWITCH IDENTIFIER keyword_lcurly ExprCaseClauseList keyword_rcurly
<<0
b = False
for scope in symTableSt:
	if p[2] in symTableDict[scope].symbols:
		b = True
		break
if not b:
	print("Switch variable", p[2], "not declared on line number", p.lexer.lineno)
p[0]['code'] = p[4]['expcodelist']
for exp, label in zip(p[4]['explist'], p[4]['labellist'][:-1]):
	p[0]['code'] += ['if ' + p[2] + ' == ' + exp + ' goto ' + label]
for label, codeblock in zip(p[4]['labellist'], p[4]['code'][:-1]):
	p[0]['code'] += [label + ' : '] + codeblock
	p[0]['code'] += ['goto ' + p[4]['labellist'][-1]]
>>

ExprCaseClauseList : ExprCaseClause ExprCaseClauseList
                   | empty
<<1
p[0]['explist'] = p[1]['exp'] + p[2]['explist']
p[0]['expcodelist'] = p[1]['expcode'] + p[2]['expcodelist']
p[0]['labellist'] = p[1]['label'] + p[2]['labellist']
p[0]['code'] = [p[1]['code']] + [p[2]['code']]
>>
<<2
p[0]['explist'] = []
p[0]['expcodelist'] = []
p[0]['labellist'] = [newLabel()]
p[0]['code'] = []
>>

ExprCaseClause : ExprSwitchCase COLON keyword_lcurly StatementList keyword_rcurly
<<0
p[0]['exp'] = p[1]['exp']
p[0]['expcode'] = p[1]['code']
p[0]['label'] = [newLabel()]
p[0]['code'] = [p[0]['label'] + ' : '] + p[4]['code']
>>

ExprSwitchCase : CASE Expression
               | DEFAULT
<<1
p[0]['exp'] = p[2]['place']
p[0]['code'] = p[2]['code']
>>

ForStmt : FOR ExpressionBot Block

ExpressionBot : Expression
              | empty

ReturnStmt : RETURN ExpressionListBot

ExpressionListBot : ExpressionList
                  | empty

Expression : UnaryExpr
           | Expression binary_op Expression
           | IDENTIFIER DOT IDENTIFIER
           | IDENTIFIER keyword_lcurly ObjectParamList keyword_rcurly
<<0
p[0]['type'] = 'zzzzz'
>>
<<1
p[0]['code'] =p[1]['code']
p[0]['type'] =p[1]['type']
p[0]['place'] = p[1]['place']
>>
<<2
p[0]['place'] = newVar()
if p[1]['type'] == p[3]['type']:
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ':=' + p[1]['place'] + p[2]['symbol'] + p[1]['type'] + p[3]['place']]
  p[0]['type'] = p[1]['type']
elif (p[1]['type']=='float' and p[3]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ':= cast-to-float' + p[1]['place'] + p[2]['symbol'] + 'float' + p[3]['place']]
  p[0]['type'] ='float'
elif (p[3]['type']=='float' and p[1]['type']=='int'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ':= cast-to-float' + p[3]['place'] + p[2]['symbol'] + 'float' + p[1]['place']]
  p[0]['type'] ='float'
elif (p[1]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ':= cast-to-string' + p[3]['place'] + p[2]['symbol'] + 'string' + p[1]['place']]
  p[0]['type'] ='string'
elif (p[3]['type']=='string'):
  p[0]['code'] = p[1]['code'] + p[3]['code'] + [p[0]['place'] + ':= cast-to-string' + p[1]['place'] + p[2]['symbol'] + 'string' + p[3]['place']]
  p[0]['type'] ='string'
>>
<<3
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ':=' + p[1]['place'] + '.' + p[2]['place']]
>>

ObjectParamList : ObjectParam ObjectParamTop

ObjectParamTop : COMMA ObjectParamTop
               | COMMA ObjectParam
               | empty

ObjectParam   : IDENTIFIER COLON Expression

UnaryExpr  : PrimaryExpr
           | unary_op UnaryExpr
<<1
p[0]['place'] = p[1]['place']
p[0]['type'] = p[1]['type']
p[0]['code'] = p[1]['code']
>>
<<2
p[0]['place'] = newVar()
p[0]['type'] = p[2]['type']
p[0]['code'] = [p[0]['place'] + ':=' + p[1]['symbol'] + p[2]['place']]
>>

binary_op  : OR_OR
           | AND_AND
           | rel_op
           | add_op
           | mul_op
<<1
p[0]['symbol'] = p[1]
>>
<<2
p[0]['symbol'] = p[1]
>>
<<3
p[0]['symbol'] = p[1]['symbol']
>>
<<4
p[0]['symbol'] = p[1]['symbol']
>>
<<5
p[0]['symbol'] = p[1]['symbol']
>>

rel_op  : EQ_EQ
        | NOT_EQ
        | LESS
        | LESS_EQ
        | GREATER
        | GREATER_EQ
<<0
p[0]['symbol'] = p[1]
>>

add_op  : ADD
        | MINUS
        | OR
        | POW
<<0
p[0]['symbol'] = p[1]
>>

mul_op  : MULT
        | DIV
        | LSHIFT
        | RSHIFT
        		        | AND
        | AND_POW
<<0
p[0]['symbol'] = p[1]
>>

unary_op  : ADD
          | MINUS
          | NOT
          | POW
          | MULT
          | AND
          | RECEIVE
<<0
p[0]['symbol'] = p[1]
>>

PrimaryExpr : Operand
            | PrimaryExpr Selector
            | PrimaryExpr Index
            | PrimaryExpr Arguments
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = p[1]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ': =' + p[1]['place']]
>>
<<2
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['code'] += [p[0]['place'] + ': =' + p[1]['place'] + p[2]['symbol']]
>>
<<3
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ': =' + p[1]['place'] + p[2]['symbol']]
>>
<<4
p[0]['code'] = p[1]['code'] + p[2]['code']
p[0]['type'] = p[1]['type']
p[0]['code'] += [p[0]['place'] + ': =' + p[1]['place'] + p[2]['symbol']]
>>

Operand : Literal
        | OperandName
        | MethodExpr
        | LPAREN Expression RPAREN
        | TRUE
        | FALSE
<<0
p[0]['place'] = newVar()
>>
<<1
p[0]['code'] = [p[0]['place'] + ':=' + p[1]['symbol']]
p[0]['type'] = p[1]['type']
>>
<<2
p[0]['code'] = p[1]['code'] + [p[0]['place'] + ':=' + p[1]['place']]
p[0]['type'] = p[1]['type']
>>
<<4
p[0]['type'] = p[2]['type']
>>
<<5
p[0]['code'] = [p[0]['place'] + ':=true']
p[0]['type'] = 'bool'
>>
<<6
p[0]['code'] = [p[0]['place'] + ':=false']
p[0]['type'] = 'bool'
>>

Literal : BasicLit
        | FunctionLit
<<1
p[0]['type'] = p[1]['type']
p[0]['symbol'] = p[1]['symbol']
>>

BasicLit  : INTEGERLIT
          | FLOATINGLIT
          | STRINGLIT
<<0
p[0]['symbol'] = p[1]
>>
<<1
p[0]['type'] = 'int'
>>
<<2
p[0]['type'] = 'float'
>>
<<3
p[0]['type'] = 'string'
>>

OperandName : IDENTIFIER
<<0
p[0]['place'] = newVar()
p[0]['code'] = [p[0]['place'] + ':=' + p[1]]
p[0]['type'] = verifyCalType(p[1], p.lexer.lineno)
>>

FunctionLit : FUNC Function

MethodExpr  : ReceiverType DOT MethodName

ReceiverType  : TypeName
              | LPAREN MULT TypeName RPAREN
              | LPAREN ReceiverType RPAREN

Selector : DOT IDENTIFIER
<<0
p[0]['symbol'] = '.' + p[2]
>>

Index    : LSQUARE Expression RSQUARE
<<0
p[0]['symbol'] = '[' + p[2]['place'] + ']'
p[0]['code'] = p[2]['code']
>>

Arguments  : LPAREN ArgumentsHead RPAREN
<<0
p[0]['symbol'] = '(' + p[2]['symbol'] + ')'
p[0]['code'] = p[2]['code']
>>

ArgumentsHead : ArgumentsHeadMid tripledotTop commaTop
              | empty
<<1
p[0]['symbol'] = p[1]['symbol'] + p[2]['symbol'] +p[3]['symbol']
p[0]['code'] = p[1]['code']
>>

ArgumentsHeadMid  : ExpressionList
                  | Type COMMA ExpressionList
                  | Type
<<1
str = ''
for elt in p[1]['namelist'][:-1]:
    str += elt + ','
str += p[1]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[1]['code']
>>
<<2
str = p[1]['place'] + ','
for elt in p[3]['namelist'][:-1]:
    str += elt + ','
str += p[3]['namelist'][-1]
p[0]['symbol'] = str
p[0]['code'] = p[3]['code']
>>
<<3
p[0]['symbol'] = p[1]['place']
>>